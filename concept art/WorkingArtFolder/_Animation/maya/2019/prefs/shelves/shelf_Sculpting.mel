global proc shelf_Sculpting () {
    global string $gBuffStr;
    global string $gBuffStr0;
    global string $gBuffStr1;


    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Sculpt Tool: Lift a surface" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Sculpt Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Sculpt.png" 
        -image1 "Sculpt.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshSculptTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshSculptToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Smooth Tool: Even out surface detail" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Smooth Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Smooth.png" 
        -image1 "Smooth.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshSmoothTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshSmoothToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Relax Tool: Smooth the surface of a mesh without affecting its shape" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Relax Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Relax.png" 
        -image1 "Relax.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshRelaxTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshRelaxToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Grab Tool: Pull a single vertex along a surface in any direction" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Grab Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Grab.png" 
        -image1 "Grab.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshGrabTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshGrabToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Pinch Tool: Sharpen soft edges" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Pinch Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Pinch.png" 
        -image1 "Pinch.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshPinchTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshPinchToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Flatten Tool: Level a surface" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Flatten Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Flatten.png" 
        -image1 "Flatten.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshFlattenTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshFlattenToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Foamy Tool: Softly lift a surface." 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Foamy Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Foamy.png" 
        -image1 "Foamy.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshFoamyTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshFoamyToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Spray Tool: Randomly spray a stamp imprint on a surface" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Spray Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Spray.png" 
        -image1 "Spray.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshSprayTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshSprayToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Repeat Tool: Stamp a pattern on a surface" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Repeat Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Repeat.png" 
        -image1 "Repeat.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshRepeatTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshRepeatToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Imprint Tool: Imprint a single copy of a stamp on a surface" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Imprint Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Imprint.png" 
        -image1 "Imprint.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshImprintTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshImprintToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Wax Tool: Build up a surface" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Wax Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Wax.png" 
        -image1 "Wax.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshWaxTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshWaxToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Scrape Tool: Minimize or remove raised areas on a surface" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Scrape Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Scrape.png" 
        -image1 "Scrape.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshScrapeTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshScrapeToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Fill Tool: Fill in the valleys on a surface" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Fill Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Fill.png" 
        -image1 "Fill.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshFillTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshFillToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Knife Tool: Cut fine strokes into a surface" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Knife Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Knife.png" 
        -image1 "Knife.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshKnifeTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshKnifeToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Smear Tool: Pull a surface in the direction of the stroke" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Smear Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Smear.png" 
        -image1 "Smear.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshSmearTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshSmearToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Bulge Tool: Inflate an area on a surface" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Bulge Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Bulge.png" 
        -image1 "Bulge.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshBulgeTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshBulgeToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Amplify Tool: Accentuate surface detail" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Amplify Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Amplify.png" 
        -image1 "Amplify.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshAmplifyTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshAmplifyToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Freeze Tool: Paint areas of a surface to prevent further modification" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Freeze Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Freeze.png" 
        -image1 "Freeze.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SetMeshFreezeTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshFreezeToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    separator
        -enable 1
        -width 12
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -style "shelf" 
        -horizontal 0
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Convert To Frozen" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Convert To Frozen" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "freezeSelected.png" 
        -image1 "freezeSelected.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "ConvertToFrozen" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Open Content Browser for Sculpting Base Meshes" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Base Meshes" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Objects.png" 
        -image1 "Objects.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "OpenVisorForMeshes" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    separator
        -enable 1
        -width 12
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -style "shelf" 
        -horizontal 0
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Shape Editor: Create, edit and manage shapes" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Shape Editor" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "blendShapeEditor.png" 
        -image1 "blendShapeEditor.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -version "2017" 
        -command "ShapeEditor" 
        -sourceType "mel" 
        -doubleClickCommand "CreateBlendShapeOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Pose Editor: Create, edit and manage pose space deformations" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Pose Editor" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "poseEditor.png" 
        -image1 "poseEditor.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -version "2017" 
        -command "PoseEditor" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    separator
        -enable 1
        -width 12
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -style "shelf" 
        -horizontal 0
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Smooth Target Tool: Even out surface detail only for the current blend shape target in Edit mode" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Smooth Target Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "SmoothTarget.png" 
        -image1 "SmoothTarget.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -version "2017" 
        -command "SetMeshSmoothTargetTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshSmoothTargetToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Clone Target Tool: Copy edits from a blend shape target source to the current target in Edit mode" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Clone Target Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "CloneTarget.png" 
        -image1 "CloneTarget.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -version "2017" 
        -command "SetMeshCloneTargetTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshCloneTargetToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Mask Target Tool: Paint areas on a mesh to hide edits for the current blend shape target in Edit mode" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Mask Target Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Mask.png" 
        -image1 "Mask.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -version "2017" 
        -command "SetMeshMaskTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshMaskToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Erase Target Tool: Remove edits for the current blend shape target in Edit mode" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Erase Target Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "Erase.png" 
        -image1 "Erase.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -version "2017" 
        -command "SetMeshEraseTool" 
        -sourceType "mel" 
        -doubleClickCommand "ShowMeshEraseToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Set and save Maya preferences" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Preferences" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Pref" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "menuIconWindow.png" 
        -image1 "menuIconWindow.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "PreferencesWindow" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Combine the selected polygon objects into one single object to allow operations such as merges or face trims" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Combine" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "polyUnite.png" 
        -image1 "polyUnite.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "polyPerformAction polyUnite o 0" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Separate the selected polygon object shells or the shells of any selected faces from the object into distinct objects" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Separate" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "polySeparate.png" 
        -image1 "polySeparate.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SeparatePolygon" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Duplicate the selected object(s)" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Duplicate" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Dupl" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "menuIconEdit.png" 
        -image1 "menuIconEdit.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "duplicatePreset(1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1)" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Delete construction history on the selected object(s)" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "History" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Hist" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "menuIconEdit.png" 
        -image1 "menuIconEdit.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "DeleteHistory" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Select an object(s)" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Center Pivot" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "CP" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "menuIconModify.png" 
        -image1 "menuIconModify.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "CenterPivot" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Select an object(s)" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Freeze Transformations" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "FT" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "menuIconModify.png" 
        -image1 "menuIconModify.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "FreezeTransformations" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Select an object(s)" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Reset Transformations" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "RT" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "menuIconModify.png" 
        -image1 "menuIconModify.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "ResetTransformations" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Detach selected components" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Detach" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "polySplitVertex.png" 
        -image1 "polySplitVertex.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "DetachComponent" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Separate the selected polygon object shells or the shells of any selected faces from the object into distinct objects" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Separate" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "polySeparate.png" 
        -image1 "polySeparate.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SeparatePolygon" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Convert selected instance(s) to object(s)" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Instance to Object" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "instanceToObject.png" 
        -image1 "instanceToObject.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "ConvertInstanceToObject" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Game Exporter" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Game Exporter" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "GE" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "menuIconFile.png" 
        -image1 "menuIconFile.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "gameFbxExporter" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Duplicate the selected object(s)" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Duplicate Special" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "DS_Ins" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "menuIconEdit.png" 
        -image1 "menuIconEdit.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "duplicatePreset(1,0,2,0,0,0,0,0,0,0,0,0,0,0,1,1,1)" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Duplicate the selected object(s)" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Duplicate Special" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "DS-X" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "menuIconEdit.png" 
        -image1 "menuIconEdit.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "duplicatePreset(1,1,2,0,0,0,0,0,0,0,0,0,0,0,-1,1,1)" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Duplicate the selected object(s)" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Duplicate Special" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "DS" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "menuIconEdit.png" 
        -image1 "menuIconEdit.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "duplicatePreset(1,1,2,0,0,0,0,0,0,0,0,0,0,0,1,1,-1)" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "string $obj[] = `ls -sl`;\nmove -rpr 0 0 0 $obj;" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Abs XForm" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Abs XForm" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "string $obj[] = `ls -sl`;\nmove -rpr 0 0 0 $obj;" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "{\n\tstring $sSel[] = `ls -sl -typ transform`;\n\tstring $sItem;\n\n\tfor($sItem in $sSel)\n\t{\n\t\tsetAttr ($sItem + \".scalePivot\") 0 0 0;\n\t\tsetAttr ($sItem + \".rotatePivot\") 0 0 0;" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "CP Orig" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "CP Orig" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "\nxform -ws -a -rp 0 0 0\n\n" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "import sys\nimport math\nimport random\nimport traceback\nimport maya.mel as mel\nimport pymel.core as pm\nimport maya.OpenMaya as OpenMaya\nimport maya.OpenMayaUI as OpenMayaUI\nimport maya.OpenMayaMPx as OpenMayaMPx\nimport maya.OpenMayaRender as OpenMayaRender\n\nkPluginVersion = \"1.1.0\"\nkPluginCmdName = \"instanceAlongCurve\"\nkPluginCtxCmdName = \"instanceAlongCurveCtx\"\nkPluginNodeName = 'instanceAlongCurveLocator'\nkPluginManipNodeName = 'instanceAlongCurveLocatorManip'\nkPluginNodeClassify = 'utility/general'\nkPluginNodeId = OpenMaya.MTypeId( 0x55555 ) \nkPluginNodeManipId = OpenMaya.MTypeId( 0x55556 ) \n\nclass instanceAlongCurveLocator(OpenMayaMPx.MPxLocatorNode):\n\n    # Simple container class for compound vector attributes\n    class Vector3CompoundAttribute(object):\n\n        def __init__(self):            \n            self.compound = OpenMaya.MObject()\n            self.x = OpenMaya.MObject()\n            self.y = OpenMaya.MObject()\n            self.z = OpenMaya.MObject()\n\n    class CurveAxisHandleAttribute(object):\n\n        def __init__(self):\n            self.compound = OpenMaya.MObject()\n            self.parameter = OpenMaya.MObject()\n            self.angle = OpenMaya.MObject() # The angle over the tangent axis\n\n    # Legacy attributes to support backward compatibility\n    legacyInputTransformAttr = OpenMaya.MObject()\n\n    # Input attributes\n    inputCurveAttr = OpenMaya.MObject()\n    inputTransformAttr = OpenMaya.MObject()\n    inputShadingGroupAttr = OpenMaya.MObject()\n\n    # Translation offsets\n    inputLocalTranslationOffsetAttr = OpenMaya.MObject()\n    inputGlobalTranslationOffsetAttr = OpenMaya.MObject()\n\n    # Rotation offsets\n    inputLocalRotationOffsetAttr = OpenMaya.MObject()\n    inputGlobalRotationOffsetAttr = OpenMaya.MObject()\n\n    # Scale offset\n    inputLocalScaleOffsetAttr = OpenMaya.MObject()\n\n    # Instance count related attributes\n    instanceCountAttr = OpenMaya.MObject()\n    instancingModeAttr = OpenMaya.MObject()\n    instanceLengthAttr = OpenMaya.MObject()\n    maxInstancesByLengthAttr = OpenMaya.MObject()\n\n    # Curve axis data, to be manipulated by user\n    enableManipulatorsAttr = OpenMaya.MObject()\n    curveAxisHandleAttr = CurveAxisHandleAttribute()\n    curveAxisHandleCountAttr = OpenMaya.MObject()\n\n    displayTypeAttr = OpenMaya.MObject()\n    bboxAttr = OpenMaya.MObject()\n\n    orientationModeAttr = OpenMaya.MObject()\n    inputLocalOrientationAxisAttr = OpenMaya.MObject()\n\n    class RampAttributes(object):\n\n        def __init__(self):\n            self.ramp = OpenMaya.MObject() # normalized ramp\n            self.rampOffset = OpenMaya.MObject() # evaluation offset for ramp\n            self.rampAxis = OpenMaya.MObject() # ramp normalized axis\n            self.rampAmplitude = OpenMaya.MObject() # ramp amplitude\n            self.rampRandomAmplitude = OpenMaya.MObject() # ramp random amplitude\n            self.rampRepeat = OpenMaya.MObject()\n\n    # Simple container class for compound vector attributes\n    class RampValueContainer(object):\n\n        def __init__(self, mObject, dataBlock, rampAttr, normalize, instanceCount):            \n            self.ramp = OpenMaya.MRampAttribute(OpenMaya.MPlug(mObject, rampAttr.ramp))\n            self.rampOffset = dataBlock.inputValue(rampAttr.rampOffset).asFloat()\n            self.rampRandomAmplitude = dataBlock.inputValue(rampAttr.rampRandomAmplitude).asFloat()\n            self.rampAmplitude = dataBlock.inputValue(rampAttr.rampAmplitude).asFloat()\n            self.rampRepeat = dataBlock.inputValue(rampAttr.rampRepeat).asFloat()\n\n            if normalize:\n                self.rampAxis = dataBlock.inputValue(rampAttr.rampAxis.compound).asVector().normal()\n            else:\n                self.rampAxis = dataBlock.inputValue(rampAttr.rampAxis.compound).asVector()\n\n            self.useDynamicAmplitudeValues = False\n\n            amplitudePlug = OpenMaya.MPlug(mObject, rampAttr.rampAmplitude)\n\n            if amplitudePlug.isConnected():\n\n                # Get connected input plugs\n                connections = OpenMaya.MPlugArray()\n                amplitudePlug.connectedTo(connections, True, False)\n\n                # Find input transform\n                if connections.length() == 1:\n                    node = connections[0].node()\n                    nodeFn = OpenMaya.MFnDependencyNode(node)\n\n                    resultColors = OpenMaya.MFloatVectorArray()\n                    resultTransparencies = OpenMaya.MFloatVectorArray()\n\n                    uValues = OpenMaya.MFloatArray(instanceCount, 0.0)\n                    vValues = OpenMaya.MFloatArray(instanceCount, 0.0)\n\n                    # Sample a line, for more user flexibility\n                    for i in xrange(instanceCount):\n                        uValues.set(i / float(instanceCount), i)\n                        vValues.set(i / float(instanceCount), i)\n\n                    # For now... then we can just use the plug (TODO)\n                    if(node.hasFn(OpenMaya.MFn.kTexture2d)):                        \n                        \n                        OpenMayaRender.MRenderUtil.sampleShadingNetwork(nodeFn.name() + \".outColor\", instanceCount, False, False, OpenMaya.MFloatMatrix(), None, uValues, vValues, None, None, None, None, None, resultColors, resultTransparencies)\n\n                        self.rampAmplitudeValues = []\n                        self.useDynamicAmplitudeValues = True\n\n                        for i in xrange(resultColors.length()):\n                            self.rampAmplitudeValues.append(resultColors[i].length() / math.sqrt(3))\n\n    # Ramps base offset\n    distOffsetAttr = OpenMaya.MObject()\n\n    # Normalized thresholds for curve evaluation\n    curveStartAttr = OpenMaya.MObject()\n    curveEndAttr = OpenMaya.MObject()\n\n    # Ramp attributes\n    positionRampAttr = RampAttributes()\n    rotationRampAttr = RampAttributes()\n    scaleRampAttr = RampAttributes()\n\n    # Output vectors\n    outputTranslationAttr = Vector3CompoundAttribute()\n    outputRotationAttr = Vector3CompoundAttribute()\n    outputScaleAttr = Vector3CompoundAttribute()\n\n    def __init__(self):\n        OpenMayaMPx.MPxLocatorNode.__init__(self)\n\n    def postConstructor(self):\n        OpenMaya.MFnDependencyNode(self.thisMObject()).setName(\"instanceAlongCurveLocatorShape#\")\n        self.callbackId = OpenMaya.MNodeMessage.addAttributeChangedCallback(self.thisMObject(), self.attrChangeCallback)\n        self.updateInstanceConnections()\n\n    # Find original SG to reassign it to instance\n    def getShadingGroup(self):\n        inputSGPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.inputShadingGroupAttr)\n        sgNode = getSingleSourceObjectFromPlug(inputSGPlug)\n\n        if sgNode is not None and sgNode.hasFn(OpenMaya.MFn.kSet):\n            return OpenMaya.MFnSet(sgNode)\n\n        return None\n\n    def assignShadingGroup(self, fnDagNode):\n\n        fnSet = self.getShadingGroup()\n\n        if fnSet is not None:\n            # Easiest, cleanest way seems to be calling MEL.\n            # sets command handles everything, even nested instanced dag paths\n            mdgm = OpenMaya.MDGModifier()\n            mdgm.commandToExecute(\"sets -e -nw -fe \" + fnSet.name() + \" \" + fnDagNode.name())\n            mdgm.doIt()\n\n    # Helper function to get an array of available logical indices from the sparse array\n    # TODO: maybe it can be precalculated?\n    def getAvailableLogicalIndices(self, plug, numIndices):\n        \n        # Allocate and initialize\n        outIndices = OpenMaya.MIntArray(numIndices)\n        indices = OpenMaya.MIntArray(plug.numElements())\n        plug.getExistingArrayAttributeIndices(indices)\n\n        currentAvailableIndex = 0\n        indicesFound = 0\n\n        # Assuming indices are SORTED :)\n        for i in indices:\n\n            connectedPlug = plug.elementByLogicalIndex(i).isConnected()\n\n            # Iteratively find available indices in the sparse array\n            while i > currentAvailableIndex:\n                outIndices[indicesFound] = currentAvailableIndex\n                indicesFound += 1\n                currentAvailableIndex += 1\n\n            # Check against this index, add it if it is not connected\n            if i == currentAvailableIndex and not connectedPlug:\n                outIndices[indicesFound] = currentAvailableIndex\n                indicesFound += 1\n\n            currentAvailableIndex += 1\n\n            if indicesFound == numIndices:\n                return outIndices\n\n        # Fill remaining expected indices\n        for i in xrange(indicesFound, numIndices):\n            outIndices[i] = currentAvailableIndex\n            currentAvailableIndex += 1\n\n        return outIndices\n\n    def getNodeTransformFn(self):\n        dagNode = OpenMaya.MFnDagNode(self.thisMObject())\n        dagPath = OpenMaya.MDagPath()\n        dagNode.getPath(dagPath)\n        return OpenMaya.MFnDagNode(dagPath.transform())\n\n    def updateInstanceConnections(self):\n\n        # If the locator is being instanced, just stop updating its children.\n        # This is to prevent losing references to the locator instances' children\n        # If you want to change this locator, prepare the source before instantiating\n        if OpenMaya.MFnDagNode(self.thisMObject()).isInstanced():\n            return OpenMaya.kUnknownParameter\n\n        # Plugs\n        outputTranslationPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.outputTranslationAttr.compound)\n        outputRotationPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.outputRotationAttr.compound)\n        outputScalePlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.outputScaleAttr.compound)\n\n        expectedInstanceCount = self.getInstanceCountByMode()\n        numConnectedElements = outputTranslationPlug.numConnectedElements()\n\n        # Only instance if we are missing elements\n        # TODO: handle mismatches in translation/rotation plug connected elements (user deleted a plug? use connectionBroken method?)\n        if numConnectedElements < expectedInstanceCount:\n\n            inputTransformFn = self.getInputTransformFn()\n\n            if inputTransformFn is not None:\n\n                rotatePivot = inputTransformFn.rotatePivot(OpenMaya.MSpace.kTransform )\n                scalePivot = inputTransformFn.scalePivot(OpenMaya.MSpace.kTransform )\n\n                transformFn = self.getNodeTransformFn()\n                newInstancesCount = expectedInstanceCount - numConnectedElements\n                availableIndices = self.getAvailableLogicalIndices(outputTranslationPlug, newInstancesCount)\n\n                displayPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.displayTypeAttr)\n                LODPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.bboxAttr)\n\n                mdgModifier = OpenMaya.MDagModifier()\n\n                for i in availableIndices:\n                    \n                    # Instance transform\n                    # InstanceLeaf must be set to False to prevent crashes :)\n                    trInstance = inputTransformFn.duplicate(True, False)\n                    instanceFn = OpenMaya.MFnTransform(trInstance)\n\n                    # Parent new instance\n                    transformFn.addChild(trInstance)\n\n                    # Pivots\n                    instanceFn.setRotatePivot(rotatePivot, OpenMaya.MSpace.kTransform , False)\n                    instanceFn.setScalePivot(scalePivot, OpenMaya.MSpace.kTransform , False)\n\n                    instanceTranslatePlug = instanceFn.findPlug('translate', False)\n                    outputTranslationPlugElement = outputTranslationPlug.elementByLogicalIndex(i)\n\n                    instanceRotationPlug = instanceFn.findPlug('rotate', False)\n                    outputRotationPlugElement = outputRotationPlug.elementByLogicalIndex(i)\n\n                    instanceScalePlug = instanceFn.findPlug('scale', False)\n                    outputScalePlugElement = outputScalePlug.elementByLogicalIndex(i)\n\n                    # Make instance visible\n                    instanceFn.findPlug(\"visibility\", False).setBool(True)\n\n                    # Enable drawing overrides\n                    overrideEnabledPlug = instanceFn.findPlug(\"overrideEnabled\", False)\n                    overrideEnabledPlug.setBool(True)\n\n                    instanceDisplayPlug = instanceFn.findPlug(\"overrideDisplayType\", False)\n                    instanceLODPlug = instanceFn.findPlug(\"overrideLevelOfDetail\", False)\n\n                    if not outputTranslationPlugElement.isConnected():\n                        mdgModifier.connect(outputTranslationPlugElement, instanceTranslatePlug)\n\n                    if not outputRotationPlugElement.isConnected():\n                        mdgModifier.connect(outputRotationPlugElement, instanceRotationPlug)\n\n                    if not outputScalePlugElement.isConnected():\n                        mdgModifier.connect(outputScalePlugElement, instanceScalePlug)\n\n                    if not instanceDisplayPlug.isConnected():\n                        mdgModifier.connect(displayPlug, instanceDisplayPlug)\n\n                    if not instanceLODPlug.isConnected():\n                        mdgModifier.connect(LODPlug, instanceLODPlug)\n\n                mdgModifier.doIt()\n\n                # Finally, assign SG to all children\n                self.assignShadingGroup(transformFn)\n\n        # Remove instances if necessary\n        elif numConnectedElements > expectedInstanceCount:\n\n            connections = OpenMaya.MPlugArray()        \n            toRemove = numConnectedElements - expectedInstanceCount\n            mdgModifier = OpenMaya.MDGModifier()\n\n            for i in xrange(toRemove):\n                outputTranslationPlugElement = outputTranslationPlug.connectionByPhysicalIndex(numConnectedElements - 1 - i)\n                outputTranslationPlugElement.connectedTo(connections, False, True)\n\n                for c in xrange(connections.length()):\n                    mdgModifier.deleteNode(connections[c].node())\n\n            mdgModifier.doIt()\n\n    def attrChangeCallback(self, msg, plug, otherPlug, clientData):\n\n        incomingDirection = (OpenMaya.MNodeMessage.kIncomingDirection & msg) == OpenMaya.MNodeMessage.kIncomingDirection\n        attributeSet = (OpenMaya.MNodeMessage.kAttributeSet & msg) == OpenMaya.MNodeMessage.kAttributeSet\n        isCorrectAttribute = (plug.attribute() == instanceAlongCurveLocator.instanceCountAttr) \n        isCorrectAttribute = isCorrectAttribute or (plug.attribute() == instanceAlongCurveLocator.instancingModeAttr)\n        isCorrectAttribute = isCorrectAttribute or (plug.attribute() == instanceAlongCurveLocator.instanceLengthAttr)\n        isCorrectAttribute = isCorrectAttribute or (plug.attribute() == instanceAlongCurveLocator.maxInstancesByLengthAttr)\n        isCorrectAttribute = isCorrectAttribute or (plug.attribute() == instanceAlongCurveLocator.curveStartAttr)\n        isCorrectAttribute = isCorrectAttribute or (plug.attribute() == instanceAlongCurveLocator.curveEndAttr)\n\n        isCorrectNode = OpenMaya.MFnDependencyNode(plug.node()).typeName() == kPluginNodeName\n\n        try:\n            if isCorrectNode and isCorrectAttribute and attributeSet and incomingDirection:\n                self.updateInstanceConnections()\n        except:    \n            sys.stderr.write('Failed trying to update instances. stack trace: \\n')\n            sys.stderr.write(traceback.format_exc())\n\n    def getInputTransformPlug(self):\n\n        # Backward compatibility\n        inputTransformPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.inputTransformAttr)\n        legacyInputTransformPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.legacyInputTransformAttr)\n\n        if(legacyInputTransformPlug.isConnected()):\n            inputTransformPlug = legacyInputTransformPlug\n\n        return inputTransformPlug\n\n    def getInputTransformFn(self):\n\n        inputTransformPlug = self.getInputTransformPlug()\n        transform = getSingleSourceObjectFromPlug(inputTransformPlug)\n\n        # Get Fn from a DAG path to get the world transformations correctly\n        if transform is not None and transform.hasFn(OpenMaya.MFn.kTransform):\n                path = OpenMaya.MDagPath()\n                trFn = OpenMaya.MFnDagNode(transform)\n                trFn.getPath(path)\n                return OpenMaya.MFnTransform(path)\n\n        return None\n\n    def getCurveFn(self):\n        inputCurvePlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.inputCurveAttr)\n        curve = getSingleSourceObjectFromPlug(inputCurvePlug)\n\n        # Get Fn from a DAG path to get the world transformations correctly\n        if curve is not None:\n            path = OpenMaya.MDagPath()\n            trFn = OpenMaya.MFnDagNode(curve)\n            trFn.getPath(path)\n\n            path.extendToShape()\n\n            if path.node().hasFn(OpenMaya.MFn.kNurbsCurve):\n                return OpenMaya.MFnNurbsCurve(path)\n\n        return None\n\n    # Calculate expected instances by the instancing mode\n    def getInstanceCountByMode(self):\n        instancingModePlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.instancingModeAttr)\n        inputCurvePlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.inputCurveAttr)\n\n        if inputCurvePlug.isConnected() and instancingModePlug.asInt() == 1:\n            instanceLengthPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.instanceLengthAttr)\n            maxInstancesByLengthPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.maxInstancesByLengthAttr)\n            curveFn = self.getCurveFn()\n\n            # Known issue: even if the curve fn is dag path constructed, its length is not worldspace... \n            # If you want perfect distance-based instancing, freeze the transformations of the curve\n            curveLength = curveFn.length()\n\n            curveStart = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.curveStartAttr).asFloat() * curveLength\n            curveEnd = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.curveEndAttr).asFloat() * curveLength\n\n            effectiveCurveLength = min(max(curveEnd - curveStart, 0.001), curveLength)\n\n            return min(maxInstancesByLengthPlug.asInt(), int(math.ceil(effectiveCurveLength / instanceLengthPlug.asFloat())))\n\n        instanceCountPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.instanceCountAttr)\n        return instanceCountPlug.asInt()\n\n    def getRandomizedValueUnified(self, randomValue, randomAmplitude, value):\n        return (randomValue * 2.0 - 1.0) * randomAmplitude + value\n\n    def getRandomizedValue(self, random, randomAmplitude, value):\n        return (random.random() * 2.0 - 1.0) * randomAmplitude + value\n\n    # Calculate expected instances by the instancing mode\n    def getIncrementByMode(self, count, effectiveCurveLength):\n        instancingModePlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.instancingModeAttr)\n       \n        # Distance defined manually\n        if instancingModePlug.asInt() == 1:\n            instanceLengthPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.instanceLengthAttr)            \n            return instanceLengthPlug.asFloat()\n        \n        # Distance driven by count\n        return effectiveCurveLength / float(count)\n\n    def updateInstancePositions(self, curveFn, dataBlock, count, distOffset, curveStart, curveEnd, effectiveCurveLength, lengthIncrement, inputTransformPlug, inputTransformFn, axisHandlesSorted):\n\n            # Common data\n            translateArrayHandle = dataBlock.outputArrayValue(instanceAlongCurveLocator.outputTranslationAttr.compound)\n            curveLength = curveFn.length()\n            maxParam = curveFn.findParamFromLength(curveLength)\n            curveForm = curveFn.form()\n\n            # Important: enums are short! If not, the resulting int may be incorrect\n            rotMode = dataBlock.inputValue(instanceAlongCurveLocator.orientationModeAttr).asShort()\n            localRotationAxisMode = dataBlock.inputValue(instanceAlongCurveLocator.inputLocalOrientationAxisAttr).asShort()\n\n            if localRotationAxisMode == 0:\n                forward = OpenMaya.MVector.xAxis\n                up = OpenMaya.MVector.yAxis\n                right = OpenMaya.MVector.zAxis\n            elif localRotationAxisMode == 1:\n                forward = OpenMaya.MVector.yAxis\n                up = OpenMaya.MVector.zAxis\n                right = OpenMaya.MVector.xAxis\n            elif localRotationAxisMode == 2:\n                forward = OpenMaya.MVector.zAxis\n                up = OpenMaya.MVector.yAxis\n                right = OpenMaya.MVector.xAxis\n\n            # We use Z axis as forward, and adjust locally to that axis\n            referenceAxis = OpenMaya.MVector.zAxis\n            referenceUp = OpenMaya.MVector.yAxis\n\n            # Local offset is not considered for position\n            localRotation = forward.rotateTo(referenceAxis)\n\n            # Manipulator data\n            enableManipulators = dataBlock.inputValue(instanceAlongCurveLocator.enableManipulatorsAttr).asBool()\n\n            # Local translation offsets\n            localTranslationOffset = dataBlock.inputValue(instanceAlongCurveLocator.inputLocalTranslationOffsetAttr.compound).asVector()\n            globalTranslationOffset = dataBlock.inputValue(instanceAlongCurveLocator.inputGlobalTranslationOffsetAttr.compound).asVector()\n            \n            # Get pivot\n            rotatePivot = OpenMaya.MVector()\n\n            if inputTransformPlug.isConnected():\n                rotatePivot = OpenMaya.MVector(inputTransformFn.rotatePivot(OpenMaya.MSpace.kTransform ))\n                rotatePivot += OpenMaya.MVector(inputTransformFn.rotatePivotTranslation(OpenMaya.MSpace.kTransform ))\n\n            # Deterministic random\n            random.seed(count)\n            rampValues = instanceAlongCurveLocator.RampValueContainer(self.thisMObject(), dataBlock, instanceAlongCurveLocator.positionRampAttr, False, count)\n\n            inputTransformRotation = OpenMaya.MQuaternion()\n\n            # First, map parameter\n            if inputTransformPlug.isConnected():\n                inputTransformFn.getRotation(inputTransformRotation, OpenMaya.MSpace.kWorld)\n\n            # Make sure there are enough handles...\n            for i in xrange(min(count, translateArrayHandle.elementCount())):\n\n                dist = math.fmod(curveStart + math.fmod(lengthIncrement * i + distOffset, effectiveCurveLength), curveLength)\n                param = max( min( curveFn.findParamFromLength( dist ), maxParam ), 0.0)\n\n                # Ramps are not modified by curve start/end, so objects can \"slide\"\n                normalizedDistance = dist / curveFn.length()\n                rampValue = self.getRampValueAtNormalizedPosition(rampValues, normalizedDistance)\n                \n                # Get the actual point on the curve...\n                point = OpenMaya.MPoint()\n                curveFn.getPointAtParam(param, point)\n\n                tangent = curveFn.tangent(param)\n                rot = referenceAxis.rotateTo(tangent)\n\n                # If the axis is parallel, but with inverse direction, rotate it PI over the up vector\n                if referenceAxis.isParallel(tangent) and (referenceAxis * tangent < 0):\n                    rot = OpenMaya.MQuaternion(math.pi, referenceUp)\n\n                # Transform rotation so that it is aligned with the tangent. This fixes unintentional twisting\n                rot = localRotation * rot\n                \n                # Modify resulting rotation based on mode\n                if rotMode == 0:                    # Identity\n                    rot = OpenMaya.MQuaternion()\n                elif rotMode == 1:                  # Input rotation\n                    rot = inputTransformRotation;\n                elif rotMode == 3 and i % 2 == 1:   # Chain mode, interesting for position ;)\n                    rot *= OpenMaya.MQuaternion(math.pi * .5, tangent)\n\n                # Get the angle from handles, and rotate over tangent axis\n                if enableManipulators:\n                    angle = self.getRotationForParam(param, axisHandlesSorted, curveForm, maxParam)\n                    rot = rot * OpenMaya.MQuaternion(-angle, tangent)\n\n                # The curve basis used for twisting\n                basisForward = forward.rotateBy(rot)\n                basisUp = up.rotateBy(rot)\n                basisRight = right.rotateBy(rot)\n\n                rampAmplitude = self.getRampAmplitudeForInstance(rampValues, i)\n\n                twistNormal = basisRight * self.getRandomizedValue(random, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.x\n                twistTangent = basisUp * self.getRandomizedValue(random, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.y\n                twistBitangent = basisForward * self.getRandomizedValue(random, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.z\n\n                twist = (twistNormal + twistTangent + twistBitangent)\n\n                # Twist + global offset, without pivot\n                point += twist + globalTranslationOffset - rotatePivot\n\n                # Local offset\n                point += basisRight * localTranslationOffset.x + basisUp * localTranslationOffset.y + basisForward * localTranslationOffset.z\n\n                translateArrayHandle.jumpToArrayElement(i)\n                translateHandle = translateArrayHandle.outputValue()\n                translateHandle.set3Double(point.x, point.y, point.z)\n\n            translateArrayHandle.setAllClean()\n            translateArrayHandle.setClean()\n\n    def getRampAmplitudeForInstance(self, rampValues, instanceIndex):\n\n        if rampValues.useDynamicAmplitudeValues:\n\n            if len(rampValues.rampAmplitudeValues) > instanceIndex:\n                return rampValues.rampAmplitudeValues[instanceIndex]\n\n        return rampValues.rampAmplitude\n\n    def getRampValueAtNormalizedPosition(self, rampValues, v):\n\n        util = OpenMaya.MScriptUtil()\n        util.createFromDouble(0.0)\n        valuePtr = util.asFloatPtr()\n        \n        position = math.fmod((v * rampValues.rampRepeat) + rampValues.rampOffset, 1.0)\n        rampValues.ramp.getValueAtPosition(position, valuePtr)\n\n        return util.getFloat(valuePtr)\n\n    def updateInstanceScale(self, curveFn, dataBlock, count, distOffset, curveStart, curveEnd, effectiveCurveLength, lengthIncrement):\n\n            point = OpenMaya.MPoint()\n            curveLength = curveFn.length()\n            maxParam = curveFn.findParamFromLength(curveLength)\n            scaleArrayHandle = dataBlock.outputArrayValue(instanceAlongCurveLocator.outputScaleAttr.compound)\n\n            localScaleOffset = dataBlock.inputValue(instanceAlongCurveLocator.inputLocalScaleOffsetAttr.compound).asVector()\n\n            # Deterministic random\n            random.seed(count)\n            rampValues = instanceAlongCurveLocator.RampValueContainer(self.thisMObject(), dataBlock, instanceAlongCurveLocator.scaleRampAttr, False, count)\n\n            # Make sure there are enough handles...\n            for i in xrange(min(count, scaleArrayHandle.elementCount())):\n\n                dist = math.fmod(curveStart + math.fmod(lengthIncrement * i + distOffset, effectiveCurveLength), curveLength)\n                param = max( min( curveFn.findParamFromLength( dist ), maxParam ), 0.0)\n\n                # Ramps are not modified by curve start/end, so objects can \"slide\"\n                normalizedDistance = dist / curveFn.length()\n                rampValue = self.getRampValueAtNormalizedPosition(rampValues, normalizedDistance)\n\n                unifiedRandom = random.random()\n                rampAmplitude = self.getRampAmplitudeForInstance(rampValues, i)\n\n                # Scales are unified... because it makes more sense\n                point.x = localScaleOffset.x + self.getRandomizedValueUnified(unifiedRandom, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.x\n                point.y = localScaleOffset.y + self.getRandomizedValueUnified(unifiedRandom, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.y\n                point.z = localScaleOffset.z + self.getRandomizedValueUnified(unifiedRandom, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.z\n\n                scaleArrayHandle.jumpToArrayElement(i)\n                scaleHandle = scaleArrayHandle.outputValue()\n                scaleHandle.set3Double(point.x, point.y, point.z)\n\n            scaleArrayHandle.setAllClean()\n            scaleArrayHandle.setClean()\n\n    # TODO: cache this data to prevent recalculating when there is no manipulator being updated\n    def getRotationForParam(self, param, axisHandlesSorted, curveForm, curveMaxParam):\n\n        indexRange = (-1, -1)\n        wrapAround = not (curveForm is OpenMaya.MFnNurbsCurve.kOpen)\n\n        # Find the range of indices that make up this curve segment\n        for i in xrange(len(axisHandlesSorted)):\n\n            # TODO: could use a binary search\n            if param < axisHandlesSorted[i][1]:\n\n                if i > 0:\n                    indexRange = (i - 1, i)\n                    break\n                elif wrapAround:\n                    indexRange = (len(axisHandlesSorted) - 1, 0)\n                    break\n                else:\n                    indexRange = (0, 0)\n                    break\n\n        # Edge case\n        if indexRange[0] == -1 and indexRange[1] == -1 and len(axisHandlesSorted) > 0:\n            if wrapAround:\n                indexRange = (len(axisHandlesSorted) - 1, 0)\n            else:\n                indexRange = (len(axisHandlesSorted) - 1, len(axisHandlesSorted) - 1)\n            \n        # Now find the lerp value based on the range\n        if indexRange[0] > -1 and indexRange[1] > -1:\n            minParam = axisHandlesSorted[indexRange[0]][1]\n            maxParam = axisHandlesSorted[indexRange[1]][1]\n\n            minAxis = axisHandlesSorted[indexRange[0]][2]\n            maxAxis = axisHandlesSorted[indexRange[1]][2]\n\n            if(math.fabs(minParam - maxParam) > 0.001):\n\n                if minParam > maxParam and wrapAround:\n\n                    if param < maxParam:\n                        param = param + curveMaxParam\n\n                    maxParam = maxParam + curveMaxParam\n                \n                t = min(max((param - minParam) / (maxParam - minParam), 0.0), 1.0)\n\n                return minAxis + (maxAxis - minAxis) * t\n\n            return minAxis\n\n        return 0.0\n\n    def updateInstanceRotations(self, curveFn, dataBlock, count, distOffset, curveStart, curveEnd, effectiveCurveLength, lengthIncrement, inputTransformPlug, inputTransformFn, axisHandlesSorted):\n\n        # Common data\n        curveLength = curveFn.length()\n        maxParam = curveFn.findParamFromLength(curveLength)\n        curveForm = curveFn.form()\n        rotationArrayHandle = dataBlock.outputArrayValue(instanceAlongCurveLocator.outputRotationAttr.compound)\n\n        # All offsets are in degrees\n        localRotationOffset = dataBlock.inputValue(instanceAlongCurveLocator.inputLocalRotationOffsetAttr.compound).asVector() * math.radians(1)\n        globalRotationOffset = dataBlock.inputValue(instanceAlongCurveLocator.inputGlobalRotationOffsetAttr.compound).asVector() * math.radians(1)\n\n        localRotationOffset = OpenMaya.MEulerRotation(localRotationOffset.x, localRotationOffset.y, localRotationOffset.z).asQuaternion()\n        globalRotationOffset = OpenMaya.MEulerRotation(globalRotationOffset.x, globalRotationOffset.y, globalRotationOffset.z).asQuaternion()\n\n        # Important: enums are short! If not, the resulting int may be incorrect\n        rotMode = dataBlock.inputValue(instanceAlongCurveLocator.orientationModeAttr).asShort()\n        localRotationAxisMode = dataBlock.inputValue(instanceAlongCurveLocator.inputLocalOrientationAxisAttr).asShort()\n\n        if localRotationAxisMode == 0:\n            forward = OpenMaya.MVector.xAxis\n            up = OpenMaya.MVector.yAxis\n            right = OpenMaya.MVector.zAxis\n        elif localRotationAxisMode == 1:\n            forward = OpenMaya.MVector.yAxis\n            up = OpenMaya.MVector.zAxis\n            right = OpenMaya.MVector.xAxis\n        elif localRotationAxisMode == 2:\n            forward = OpenMaya.MVector.zAxis\n            up = OpenMaya.MVector.yAxis\n            right = OpenMaya.MVector.xAxis\n\n        # We use Z axis as forward, and adjust locally to that axis\n        referenceAxis = OpenMaya.MVector.zAxis\n        referenceUp = OpenMaya.MVector.yAxis\n\n        # Rotation to align selected (local) forward axis to the reference forward axis (which is aligned with tangent)\n        localRotation = localRotationOffset * forward.rotateTo(referenceAxis)\n\n        # Deterministic random\n        random.seed(count)\n        rampValues = instanceAlongCurveLocator.RampValueContainer(self.thisMObject(), dataBlock, instanceAlongCurveLocator.rotationRampAttr, True, count)\n\n        # Manipulator stuff\n        enableManipulators = dataBlock.inputValue(instanceAlongCurveLocator.enableManipulatorsAttr).asBool()\n\n        # Original transform data\n        inputTransformRotation = OpenMaya.MQuaternion()\n\n        # First, map parameter\n        if inputTransformPlug.isConnected():\n            inputTransformFn.getRotation(inputTransformRotation, OpenMaya.MSpace.kWorld)\n\n        for i in xrange(min(count, rotationArrayHandle.elementCount())):\n            \n            dist = math.fmod(curveStart + math.fmod(lengthIncrement * i + distOffset, effectiveCurveLength), curveLength)\n            param = max( min( curveFn.findParamFromLength( dist ), maxParam ), 0.0)\n\n            # Ramps are not modified by curve start/end, so objects can \"slide\"\n            normalizedDistance = dist / curveFn.length()\n            rampValue = self.getRampValueAtNormalizedPosition(rampValues, normalizedDistance)\n\n            tangent = curveFn.tangent(param)\n\n            # Reference axis (Z) is now aligned with tangent\n            rot = referenceAxis.rotateTo(tangent)\n\n            # If the axis is parallel, but with inverse direction, rotate it PI over the up vector\n            if referenceAxis.isParallel(tangent) and (referenceAxis * tangent < 0):\n                rot = OpenMaya.MQuaternion(math.pi, referenceUp)\n\n            # Rotate local axis to align with tangent\n            rot = localRotation * rot\n            \n            # The curve basis used for twisting        \n            basisForward = forward.rotateBy(rot)\n            basisUp = up.rotateBy(rot)\n            basisRight = right.rotateBy(rot)\n\n            rampAmplitude = self.getRampAmplitudeForInstance(rampValues, i)\n\n            twistNormal = self.getRandomizedValue(random, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.x                \n            twistNormal = OpenMaya.MQuaternion(math.radians(twistNormal), basisRight) #X\n\n            twistTangent = self.getRandomizedValue(random, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.y\n            twistTangent = OpenMaya.MQuaternion(math.radians(twistTangent), basisUp) #Y\n\n            twistBitangent = self.getRandomizedValue(random, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.z\n            twistBitangent = OpenMaya.MQuaternion(math.radians(twistBitangent), basisForward) #Z\n\n            # Modify resulting rotation based on mode\n            if rotMode == 0:                    # Identity\n                rot = OpenMaya.MQuaternion()\n            elif rotMode == 1:                  # Input rotation\n                rot = inputTransformRotation;\n            elif rotMode == 3 and i % 2 == 1:   # Chain mode\n                rot *= OpenMaya.MQuaternion(math.pi * .5, tangent)\n\n            # Get the angle from handles, and rotate over tangent axis\n            if enableManipulators:\n                angle = self.getRotationForParam(param, axisHandlesSorted, curveForm, maxParam)\n                rot = rot * OpenMaya.MQuaternion(-angle, tangent)\n\n            rot = ((rot * twistNormal * twistTangent * twistBitangent) * globalRotationOffset).asEulerRotation().asVector()\n\n            rotationArrayHandle.jumpToArrayElement(i)\n            rotationHandle = rotationArrayHandle.outputValue()\n            rotationHandle.set3Double(rot.x, rot.y, rot.z)\n\n        rotationArrayHandle.setAllClean()\n        rotationArrayHandle.setClean()\n\n    def isBounded(self):\n        return True\n\n    def boundingBox(self):\n        return OpenMaya.MBoundingBox(OpenMaya.MPoint(-1,-1,-1), OpenMaya.MPoint(1,1,1))\n\n    def compute(self, plug, dataBlock):\n        try:\n            curveDataHandle = dataBlock.inputValue(instanceAlongCurveLocator.inputCurveAttr)\n            curve = curveDataHandle.asNurbsCurveTransformed()\n\n            updateTranslation = (plug == instanceAlongCurveLocator.outputTranslationAttr.compound)\n            updateRotation = (plug == instanceAlongCurveLocator.outputRotationAttr.compound)\n            updateScale = (plug == instanceAlongCurveLocator.outputScaleAttr.compound)\n\n            if not curve.isNull():\n\n                if updateTranslation or updateRotation or updateScale:\n                    curveFn = OpenMaya.MFnNurbsCurve(curve)\n\n                    instanceCount = self.getInstanceCountByMode()\n                    distOffset = dataBlock.inputValue(instanceAlongCurveLocator.distOffsetAttr).asFloat()\n                    curveLength = curveFn.length()\n\n                    # Curve thresholds\n                    curveStart = dataBlock.inputValue(instanceAlongCurveLocator.curveStartAttr).asFloat() * curveLength\n                    curveEnd = dataBlock.inputValue(instanceAlongCurveLocator.curveEndAttr).asFloat() * curveLength\n\n                    effectiveCurveLength = min(max(curveEnd - curveStart, 0.001), curveLength)\n                    lengthIncrement = self.getIncrementByMode(instanceCount, effectiveCurveLength)\n\n                    # Common data\n                    inputTransformPlug = self.getInputTransformPlug()\n                    inputTransformFn = self.getInputTransformFn()\n                    \n                    # Force update of transformation \n                    if OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.inputTransformAttr).isConnected():\n                        dataBlock.inputValue(inputTransformPlug).asMatrix()\n\n                    # Manipulator data\n                    curveAxisHandleArray = dataBlock.inputArrayValue(instanceAlongCurveLocator.curveAxisHandleAttr.compound)\n                    axisHandlesSorted = getSortedCurveAxisArray(self.thisMObject(), curveAxisHandleArray, instanceCount)\n\n                    if updateTranslation:\n                        self.updateInstancePositions(curveFn, dataBlock, instanceCount, distOffset, curveStart, curveEnd, effectiveCurveLength, lengthIncrement, inputTransformPlug, inputTransformFn, axisHandlesSorted)\n\n                    if updateRotation:\n                        self.updateInstanceRotations(curveFn, dataBlock, instanceCount, distOffset, curveStart, curveEnd, effectiveCurveLength, lengthIncrement, inputTransformPlug, inputTransformFn, axisHandlesSorted)\n\n                    if updateScale:\n                        self.updateInstanceScale(curveFn, dataBlock, instanceCount, distOffset, curveStart, curveEnd, effectiveCurveLength, lengthIncrement)\n\n        except:\n            sys.stderr.write('Failed trying to compute locator. stack trace: \\n')\n            sys.stderr.write(traceback.format_exc())\n            return OpenMaya.kUnknownParameter\n\n    @staticmethod\n    def nodeCreator():\n        return OpenMayaMPx.asMPxPtr( instanceAlongCurveLocator() )\n\n    @classmethod\n    def addCompoundVector3Attribute(cls, compoundAttribute, attributeName, unitType, arrayAttr, inputAttr, defaultValue):\n\n        # Schematic view of compound attribute:\n        # compoundAttribute[?]\n        #   compoundAttributeX\n        #   compoundAttributeY\n        #   compoundAttributeZ\n\n        unitAttr = OpenMaya.MFnUnitAttribute()\n        nAttr = OpenMaya.MFnNumericAttribute()\n\n        compoundAttribute.x = unitAttr.create(attributeName + \"X\", attributeName + \"X\", unitType, defaultValue.x)\n        unitAttr.setWritable( inputAttr )\n        cls.addAttribute(compoundAttribute.x)\n\n        compoundAttribute.y = unitAttr.create(attributeName + \"Y\", attributeName + \"Y\", unitType, defaultValue.y)\n        unitAttr.setWritable( inputAttr )\n        cls.addAttribute(compoundAttribute.y)\n\n        compoundAttribute.z = unitAttr.create(attributeName + \"Z\", attributeName + \"Z\", unitType, defaultValue.z)\n        unitAttr.setWritable( inputAttr )\n        cls.addAttribute(compoundAttribute.z)\n\n        # Output compound\n        compoundAttribute.compound = nAttr.create(attributeName, attributeName,\n                                     compoundAttribute.x, compoundAttribute.y, compoundAttribute.z)\n        nAttr.setWritable( inputAttr )\n        nAttr.setArray( arrayAttr )\n        nAttr.setUsesArrayDataBuilder( arrayAttr )\n        nAttr.setDisconnectBehavior(OpenMaya.MFnAttribute.kDelete)\n        cls.addAttribute(compoundAttribute.compound)\n\n    @classmethod\n    def addRampAttributes(cls, rampAttributes, attributeName, unitType, defaultAxisValue):\n\n        # Not a compound attribute, just adds them all to the node\n        \n        nAttr = OpenMaya.MFnNumericAttribute()\n\n        rampAttributes.ramp = OpenMaya.MRampAttribute.createCurveRamp(attributeName + \"Ramp\", attributeName + \"Ramp\")\n        cls.addAttribute(rampAttributes.ramp)\n\n        rampAttributes.rampOffset = nAttr.create(attributeName + \"RampOffset\", attributeName + \"RampOffset\", OpenMaya.MFnNumericData.kFloat, 0.0)\n        nAttr.setKeyable( True )\n        cls.addAttribute( rampAttributes.rampOffset )\n\n        rampAttributes.rampAmplitude = nAttr.create(attributeName + \"RampAmplitude\", attributeName + \"RampAmplitude\", OpenMaya.MFnNumericData.kFloat, 0.0)\n        nAttr.setKeyable( True )\n        cls.addAttribute( rampAttributes.rampAmplitude )\n\n        rampAttributes.rampRepeat = nAttr.create(attributeName + \"RampRepeat\", attributeName + \"RampRepeat\", OpenMaya.MFnNumericData.kFloat, 1.0)\n        nAttr.setKeyable( True )\n        cls.addAttribute( rampAttributes.rampRepeat )\n\n        rampAttributes.rampRandomAmplitude = nAttr.create(attributeName + \"RampRandomAmplitude\", attributeName + \"RampRandomAmplitude\", OpenMaya.MFnNumericData.kFloat, 0.0)\n        nAttr.setMin(0.0)\n        nAttr.setSoftMax(1.0)\n        nAttr.setKeyable( True )\n        cls.addAttribute( rampAttributes.rampRandomAmplitude )\n\n        cls.addCompoundVector3Attribute(rampAttributes.rampAxis, attributeName + \"RampAxis\", unitType, False, True, defaultAxisValue)\n\n    @classmethod\n    def addCurveAxisHandleAttribute(cls, curveAxisHandleAttr, attributeName, defaultAxisValue):\n\n        # Schematic view of compound attribute:\n        # curveAxisHandle[]\n        #   curveAxisHandleParameter\n        #   curveAxisHandleAngle\n\n        nAttr = OpenMaya.MFnNumericAttribute()\n        cmpAttr = OpenMaya.MFnCompoundAttribute()\n\n        curveAxisHandleAttr.parameter = nAttr.create(attributeName + \"Parameter\", attributeName + \"Parameter\", OpenMaya.MFnNumericData.kDouble, 0.0)\n        nAttr.setWritable( True )\n        cls.addAttribute(curveAxisHandleAttr.parameter)\n\n        curveAxisHandleAttr.angle = nAttr.create(attributeName + \"Angle\", attributeName + \"Angle\", OpenMaya.MFnNumericData.kDouble, 0.0)\n        nAttr.setWritable( True )\n        cls.addAttribute(curveAxisHandleAttr.angle)\n\n        # cls.addCompoundVector3Attribute(curveAxisHandleAttr.axis, attributeName + \"Axis\", OpenMaya.MFnUnitAttribute.kAngle, False, True, defaultAxisValue)\n\n        # Build compound array attribute\n        curveAxisHandleAttr.compound = cmpAttr.create(attributeName, attributeName)\n        cmpAttr.addChild(curveAxisHandleAttr.parameter)\n        cmpAttr.addChild(curveAxisHandleAttr.angle)\n        cmpAttr.setWritable( True )\n        cmpAttr.setArray( True )\n        cmpAttr.setUsesArrayDataBuilder( True )\n\n        cls.addAttribute(curveAxisHandleAttr.compound)\n\n    @staticmethod\n    def nodeInitializer():\n\n        # Associate the node with its aim manipulator\n        OpenMayaMPx.MPxManipContainer.addToManipConnectTable(kPluginNodeId)\n\n        # To make things more readable\n        node = instanceAlongCurveLocator\n\n        nAttr = OpenMaya.MFnNumericAttribute()\n        matrixAttrFn = OpenMaya.MFnMatrixAttribute()\n        msgAttributeFn = OpenMaya.MFnMessageAttribute()\n        curveAttributeFn = OpenMaya.MFnTypedAttribute()\n        enumFn = OpenMaya.MFnEnumAttribute()\n\n        node.inputTransformAttr = matrixAttrFn.create(\"inputTransformMatrix\", \"inputTransformMatrix\", OpenMaya.MFnMatrixAttribute.kFloat)\n        node.addAttribute( node.inputTransformAttr )\n\n        node.legacyInputTransformAttr = msgAttributeFn.create(\"inputTransform\", \"it\")\n        node.addAttribute( node.legacyInputTransformAttr)\n\n        node.inputShadingGroupAttr = msgAttributeFn.create(\"inputShadingGroup\", \"iSG\")    \n        node.addAttribute( node.inputShadingGroupAttr )\n\n        # Input curve transform\n        node.inputCurveAttr = curveAttributeFn.create( 'inputCurve', 'curve', OpenMaya.MFnData.kNurbsCurve)\n        node.addAttribute( node.inputCurveAttr )\n        \n        # Input instance count    \n        node.instanceCountAttr = nAttr.create(\"instanceCount\", \"iic\", OpenMaya.MFnNumericData.kInt, 5)\n        nAttr.setMin(1)\n        nAttr.setSoftMax(100)\n        nAttr.setChannelBox( False )\n        nAttr.setConnectable( False )\n        node.addAttribute( node.instanceCountAttr)\n\n        node.addCompoundVector3Attribute(node.inputLocalRotationOffsetAttr, \"inputLocalRotationOffset\", OpenMaya.MFnUnitAttribute.kDistance, False, True, OpenMaya.MVector(0.0, 0.0, 0.0))\n        node.addCompoundVector3Attribute(node.inputGlobalRotationOffsetAttr, \"inputGlobalRotationOffset\", OpenMaya.MFnUnitAttribute.kDistance, False, True, OpenMaya.MVector(0.0, 0.0, 0.0))\n\n        node.addCompoundVector3Attribute(node.inputGlobalTranslationOffsetAttr, \"inputGlobalTranslationOffset\", OpenMaya.MFnUnitAttribute.kDistance, False, True, OpenMaya.MVector(0.0, 0.0, 0.0))\n        node.addCompoundVector3Attribute(node.inputLocalTranslationOffsetAttr, \"inputLocalTranslationOffset\", OpenMaya.MFnUnitAttribute.kDistance, False, True, OpenMaya.MVector(0.0, 0.0, 0.0))\n\n        node.addCompoundVector3Attribute(node.inputLocalScaleOffsetAttr, \"inputLocalScaleOffset\", OpenMaya.MFnUnitAttribute.kDistance, False, True, OpenMaya.MVector(1.0, 1.0, 1.0))\n\n        # Curve parameter offset\n        node.distOffsetAttr = nAttr.create(\"distOffset\", \"pOffset\", OpenMaya.MFnNumericData.kFloat, 0.0)\n        nAttr.setMin(0.0)\n        nAttr.setKeyable( True )\n        node.addAttribute( node.distOffsetAttr )\n\n        node.curveStartAttr = nAttr.create(\"curveStart\", \"cStart\", OpenMaya.MFnNumericData.kFloat, 0.0)\n        nAttr.setMin(0.0)\n        nAttr.setSoftMax(1.0)\n        nAttr.setKeyable( True )\n        node.addAttribute( node.curveStartAttr)\n\n        node.curveEndAttr = nAttr.create(\"curveEnd\", \"cEnd\", OpenMaya.MFnNumericData.kFloat, 1.0)\n        nAttr.setMin(0.0)\n        nAttr.setSoftMax(1.0)\n        nAttr.setKeyable( True )\n        node.addAttribute( node.curveEndAttr)\n\n        ## Max instances when defined by instance length\n        node.maxInstancesByLengthAttr = nAttr.create(\"maxInstancesByLength\", \"mibl\", OpenMaya.MFnNumericData.kInt, 50)\n        nAttr.setMin(0)\n        nAttr.setSoftMax(200)\n        nAttr.setChannelBox( False )\n        nAttr.setConnectable( False )\n        node.addAttribute( node.maxInstancesByLengthAttr)\n\n        # Length between instances\n        node.instanceLengthAttr = nAttr.create(\"instanceLength\", \"ilength\", OpenMaya.MFnNumericData.kFloat, 1.0)\n        nAttr.setMin(0.01)\n        nAttr.setSoftMax(1.0)\n        nAttr.setChannelBox( False )\n        nAttr.setConnectable( False )\n        node.addAttribute( node.instanceLengthAttr)\n        \n        # Display override options\n        node.displayTypeAttr = enumFn.create('instanceDisplayType', 'idt')\n        enumFn.addField( \"Normal\", 0 );\n        enumFn.addField( \"Template\", 1 );\n        enumFn.addField( \"Reference\", 2 );\n        enumFn.setDefault(\"Reference\")\n        node.addAttribute( node.displayTypeAttr )\n\n        # Enum for selection of instancing mode\n        node.instancingModeAttr = enumFn.create('instancingMode', 'instancingMode')\n        enumFn.addField( \"Count\", 0 );\n        enumFn.addField( \"Distance\", 1 );\n        node.addAttribute( node.instancingModeAttr )\n\n         # Enum for selection of orientation mode\n        node.orientationModeAttr = enumFn.create('orientationMode', 'orientationMode')\n        enumFn.addField( \"Identity\", 0 );\n        enumFn.addField( \"Copy from Source\", 1 );\n        enumFn.addField( \"Use Curve\", 2 );\n        enumFn.addField( \"Chain\", 3 );\n        enumFn.setDefault(\"Use Curve\")\n        node.addAttribute( node.orientationModeAttr )\n\n        node.inputLocalOrientationAxisAttr = enumFn.create('inputLocalOrientationAxis', 'inputLocalOrientationAxis')\n        enumFn.addField(\"X\", 0)\n        enumFn.addField(\"Y\", 1)\n        enumFn.addField(\"Z\", 2)\n        enumFn.setDefault(\"Z\")\n        node.addAttribute( node.inputLocalOrientationAxisAttr )\n\n        node.bboxAttr = nAttr.create('instanceBoundingBox', 'ibb', OpenMaya.MFnNumericData.kBoolean)\n        node.addAttribute( node.bboxAttr )\n\n        # Default translation ramp axis is UP\n        node.addRampAttributes(node.positionRampAttr, \"position\", OpenMaya.MFnUnitAttribute.kDistance, OpenMaya.MVector(0.0, 1.0, 0.0))\n\n        # Default rotation ramp axis is TANGENT\n        node.addRampAttributes(node.rotationRampAttr, \"rotation\", OpenMaya.MFnUnitAttribute.kDistance, OpenMaya.MVector(0.0, 0.0, 1.0))\n\n        # Default scale axis is uniform\n        node.addRampAttributes(node.scaleRampAttr, \"scale\", OpenMaya.MFnUnitAttribute.kDistance, OpenMaya.MVector(1.0, 1.0, 1.0))\n\n        # Output attributes\n        node.addCompoundVector3Attribute(node.outputTranslationAttr, \"outputTranslation\", OpenMaya.MFnUnitAttribute.kDistance, True, False, OpenMaya.MVector(0.0, 0.0, 0.0))\n        node.addCompoundVector3Attribute(node.outputRotationAttr, \"outputRotation\", OpenMaya.MFnUnitAttribute.kAngle, True, False, OpenMaya.MVector(0.0, 0.0, 0.0))\n        node.addCompoundVector3Attribute(node.outputScaleAttr, \"outputScale\", OpenMaya.MFnUnitAttribute.kDistance, True, False, OpenMaya.MVector(1.0, 1.0, 1.0))\n\n        ## Input instance count    \n        node.enableManipulatorsAttr = nAttr.create(\"enableManipulators\", \"enableManipulators\", OpenMaya.MFnNumericData.kBoolean)\n        node.addAttribute( node.enableManipulatorsAttr)\n\n        node.addCurveAxisHandleAttribute(node.curveAxisHandleAttr, \"curveAxisHandle\", OpenMaya.MVector(0.0,0.0,0.0))\n\n        ## Input handle count\n        node.curveAxisHandleCountAttr = nAttr.create(\"curveAxisHandleCount\", \"curveAxisHandleCount\", OpenMaya.MFnNumericData.kInt, 5)\n        nAttr.setMin(1)\n        nAttr.setSoftMax(100)\n        nAttr.setChannelBox( False )\n        nAttr.setConnectable( False )\n        node.addAttribute( node.curveAxisHandleCountAttr)\n\n        def rampAttributeAffects(rampAttributes, affectedAttr):\n            node.attributeAffects( rampAttributes.ramp, affectedAttr)\n            node.attributeAffects( rampAttributes.rampOffset, affectedAttr)\n            node.attributeAffects( rampAttributes.rampAmplitude, affectedAttr)\n            node.attributeAffects( rampAttributes.rampAxis.compound, affectedAttr)\n            node.attributeAffects( rampAttributes.rampRandomAmplitude, affectedAttr)\n            node.attributeAffects( rampAttributes.rampRepeat, affectedAttr)\n\n        # Curve Axis affects, for manipulator\n        node.attributeAffects( node.inputCurveAttr, node.curveAxisHandleAttr.compound )\n        node.attributeAffects( node.curveAxisHandleCountAttr, node.curveAxisHandleAttr.compound )\n\n        # Translation affects\n        node.attributeAffects( node.inputCurveAttr, node.outputTranslationAttr.compound )\n        node.attributeAffects( node.instanceCountAttr, node.outputTranslationAttr.compound)\n        node.attributeAffects( node.instanceLengthAttr, node.outputTranslationAttr.compound)\n        node.attributeAffects( node.instancingModeAttr, node.outputTranslationAttr.compound)\n        node.attributeAffects( node.maxInstancesByLengthAttr, node.outputTranslationAttr.compound)\n        node.attributeAffects( node.distOffsetAttr, node.outputTranslationAttr.compound )\n        node.attributeAffects( node.inputTransformAttr, node.outputTranslationAttr.compound )\n\n        node.attributeAffects( node.inputLocalOrientationAxisAttr, node.outputTranslationAttr.compound)\n\n        node.attributeAffects(node.inputLocalTranslationOffsetAttr.compound, node.outputTranslationAttr.compound )\n        node.attributeAffects(node.inputGlobalTranslationOffsetAttr.compound, node.outputTranslationAttr.compound )\n\n        node.attributeAffects( node.enableManipulatorsAttr, node.outputTranslationAttr.compound)\n        node.attributeAffects( node.curveAxisHandleAttr.compound, node.outputTranslationAttr.compound)\n\n        node.attributeAffects( node.curveStartAttr, node.outputTranslationAttr.compound )\n        node.attributeAffects( node.curveEndAttr, node.outputTranslationAttr.compound )\n\n        rampAttributeAffects(node.positionRampAttr, node.outputTranslationAttr.compound)\n\n        # Rotation affects\n        node.attributeAffects( node.inputCurveAttr, node.outputRotationAttr.compound )\n        node.attributeAffects( node.instanceCountAttr, node.outputRotationAttr.compound)\n        node.attributeAffects( node.instanceLengthAttr, node.outputRotationAttr.compound)\n        node.attributeAffects( node.instancingModeAttr, node.outputRotationAttr.compound)\n        node.attributeAffects( node.maxInstancesByLengthAttr, node.outputRotationAttr.compound)\n        node.attributeAffects( node.orientationModeAttr, node.outputRotationAttr.compound)\n        node.attributeAffects( node.distOffsetAttr, node.outputRotationAttr.compound )\n        node.attributeAffects( node.inputTransformAttr, node.outputRotationAttr.compound )\n\n        node.attributeAffects( node.inputLocalOrientationAxisAttr, node.outputRotationAttr.compound)\n        \n        node.attributeAffects( node.enableManipulatorsAttr, node.outputRotationAttr.compound)\n        node.attributeAffects( node.curveAxisHandleAttr.compound, node.outputRotationAttr.compound)\n\n        node.attributeAffects( node.inputGlobalRotationOffsetAttr.compound, node.outputRotationAttr.compound)\n        node.attributeAffects( node.inputLocalRotationOffsetAttr.compound, node.outputRotationAttr.compound)        \n\n        rampAttributeAffects(node.rotationRampAttr, node.outputRotationAttr.compound)\n\n        node.attributeAffects( node.curveStartAttr, node.outputRotationAttr.compound )\n        node.attributeAffects( node.curveEndAttr, node.outputRotationAttr.compound )\n\n        # Scale affects\n        node.attributeAffects( node.inputCurveAttr, node.outputScaleAttr.compound )\n        node.attributeAffects( node.instanceCountAttr, node.outputScaleAttr.compound)\n        node.attributeAffects( node.instanceLengthAttr, node.outputScaleAttr.compound)\n        node.attributeAffects( node.instancingModeAttr, node.outputScaleAttr.compound)\n        node.attributeAffects( node.maxInstancesByLengthAttr, node.outputScaleAttr.compound)\n        node.attributeAffects( node.distOffsetAttr, node.outputScaleAttr.compound )\n        node.attributeAffects( node.inputTransformAttr, node.outputScaleAttr.compound )\n\n        node.attributeAffects( node.inputLocalOrientationAxisAttr, node.outputScaleAttr.compound)\n        \n        node.attributeAffects( node.enableManipulatorsAttr, node.outputScaleAttr.compound)\n        node.attributeAffects( node.curveAxisHandleAttr.compound, node.outputScaleAttr.compound)\n\n        rampAttributeAffects(node.scaleRampAttr, node.outputScaleAttr.compound)\n\n        node.attributeAffects( node.curveStartAttr, node.outputScaleAttr.compound )\n        node.attributeAffects( node.curveEndAttr, node.outputScaleAttr.compound )\n\n        node.attributeAffects(node.inputLocalScaleOffsetAttr.compound, node.outputScaleAttr.compound )\n\n###############\n# AE TEMPLATE #\n###############\ndef loadAETemplateCallback(nodeName):\n    AEinstanceAlongCurveLocatorTemplate(nodeName)\n\nclass AEinstanceAlongCurveLocatorTemplate(pm.ui.AETemplate):\n\n    def addControl(self, control, label=None, **kwargs):\n        pm.ui.AETemplate.addControl(self, control, label=label, **kwargs)\n\n    def beginLayout(self, name, collapse=True):\n        pm.ui.AETemplate.beginLayout(self, name, collapse=collapse)\n\n    def __init__(self, nodeName):\n        pm.ui.AETemplate.__init__(self,nodeName)\n        self.thisNode = None\n        self.node = pm.PyNode(self.nodeName)\n\n        if self.node.type() == kPluginNodeName:\n\n            # Suppress all attributes, so that no extra controls are shown\n            for attr in pm.listAttr(nodeName):\n                self.suppress(attr)\n\n            self.callCustom(lambda: self.showTitle(), lambda: None)\n\n            self.beginScrollLayout()\n\n            self.beginLayout(\"General\", collapse=0)\n\n            # Base controls\n            annotation = \"Defines if the amount of instances is defined manually or by a predefined distance.\"\n            self.addControl(\"instancingMode\", label=\"Instancing Mode\", changeCommand=self.onInstanceModeChanged, annotation=annotation)\n\n            annotation = \"The amount of instances to distribute. These are distributed uniformly.\"\n            self.addControl(\"instanceCount\", label=\"Count\", changeCommand=self.onInstanceModeChanged, annotation=annotation)\n\n            annotation = \"If the locator mode is on Distance, this length will define the spacing between each instance. <br> <br> Note that if the curve length is greater than an integer amount of distances, some space will be left unoccupied.\"\n            self.addControl(\"instanceLength\", label=\"Distance\", changeCommand=self.onInstanceModeChanged, annotation=annotation)\n\n            annotation = \"A safe guard to prevent having too many instances.\"\n            self.addControl(\"maxInstancesByLength\", label=\"Max Instances\", changeCommand=self.onInstanceModeChanged, annotation=annotation)\n\n            self.addSeparator()\n\n            annotation = \"An offset for the evaluation of the curve position/rotation. This also modifies the ramp evaluation. \"\n            self.addControl(\"distOffset\", label=\"Curve Offset\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"distOffset\"), annotation=annotation)\n\n            annotation = \"A cutoff value for the curve start point. This is normalized, so it should be in [0,1), but can have greater values for looping\"\n            self.addControl(\"curveStart\", label=\"Curve Start\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"curveStart\"), annotation=annotation)\n\n            annotation = \"A cutoff value for the curve end point. This is normalized, so it should be in (0,1], but can have greater values for looping\"\n            self.addControl(\"curveEnd\", label=\"Curve End\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"curveEnd\"), annotation=annotation)\n\n            self.addSeparator()\n\n            # Orientation controls\n            annotation = \"Identity: objects have no rotation. <br> <br> Copy From Source: Each object will copy the rotation transformation from the original. <br> <br> Use Curve: Objects will be aligned by the curve tangent with respect to the selected axis. <br> <br> Chain: Same as Use Curve, but with an additional 90 degree twist for odd instances.\"\n            self.addControl(\"orientationMode\", label=\"Orientation Mode\", changeCommand=lambda nodeName: self.updateOrientationChange(nodeName), annotation=annotation)\n\n            annotation = \"Each instance will be rotated so that this axis is parallel to the curve tangent.\"\n            self.addControl(\"inputLocalOrientationAxis\", label=\"Local Axis\" , changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputLocalOrientationAxis\"), annotation=annotation)\n\n            self.addSeparator()\n\n            # Manipulator controls\n            annotation = \"When enabled, the rotations can be manually defined.\"\n            self.addControl(\"enableManipulators\", label=\"Enable manipulators\", changeCommand=lambda nodeName: self.updateManipCountDimming(nodeName), annotation=annotation)\n\n            annotation = \"This number will define the number of handles to manipulate the curve orientation. For changes to take effect, you must click the Edit Manipulators button. <br> <br> When incrementing the number, new handles will be created in between existing ones, interpolating their values.\"\n            self.addControl(\"curveAxisHandleCount\", label=\"Manipulator count\", changeCommand=lambda nodeName: self.updateManipCountDimming(nodeName), annotation=annotation)\n            self.callCustom(lambda attr: self.buttonNew(nodeName), self.buttonUpdate, \"curveAxisHandleCount\")\n\n            self.addSeparator()\n\n            # Instance look controls\n            annotation = \"By default, objects display type is on Reference, so they cannot be selected. To change this, select Normal.\"\n            self.addControl(\"instanceDisplayType\", label=\"Instance Display Type\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"instanceDisplayType\"), annotation=annotation)\n\n            annotation = \"When true, objects will be shown as bounding boxes only.\"\n            self.addControl(\"instanceBoundingBox\", label=\"Use bounding box\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"instanceBoundingBox\"), annotation=annotation)\n            \n            self.addSeparator()\n\n            self.endLayout()\n            \n            def showRampControls(rampName):\n\n                self.beginLayout(rampName.capitalize() + \" Control\", collapse=True)\n                mel.eval('AEaddRampControl(\"' + nodeName + \".\" + rampName + 'Ramp\"); ')\n\n                annotation = \"An offset when evaluating the ramp. This is similar to the curve offset, but works only for the ramp.\"\n                self.addControl(rampName + \"RampOffset\", label= rampName.capitalize() + \" Ramp Offset\", annotation=annotation)\n\n                annotation = \"A multiplier to evaluate multiple times the same ramp over the curve\"\n                self.addControl(rampName + \"RampRepeat\", label= rampName.capitalize() + \" Ramp Repeat\", annotation=annotation)\n\n                annotation = \"Ramp values are multiplied by this amplitude.\"\n                self.addControl(rampName + \"RampAmplitude\", label= rampName.capitalize() + \" Ramp Amplitude\", annotation=annotation)\n\n                annotation = \"A random value for the ramp amplitude. The result is <br><br> amplitude + (random() * 2.0 - 1.0) * <b>randomAmplitude</b>\"\n                self.addControl(rampName + \"RampRandomAmplitude\", label= rampName.capitalize() + \" Ramp Random\", annotation=annotation)\n\n                annotation = \"The axis over which the ramp is evaluated. The result depends on the type of ramp. <br> <br> The (X,Y,Z) values are over the local space of the transformed object (right/bitangent, up/normal, forward/tangent).\"\n                self.addControl(rampName + \"RampAxis\", label= rampName.capitalize() + \" Ramp Axis\", annotation=annotation)\n\n                self.endLayout()\n\n            self.beginLayout(\"Offsets\", collapse=True)\n\n            annotation = \"A translation offset over the curve local space.\"\n            self.addControl(\"inputLocalTranslationOffset\", label=\"Local Translation Offset\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputLocalTranslationOffset\"), annotation=annotation)\n\n            annotation = \"A translation offset in worldspace XYZ.\"\n            self.addControl(\"inputGlobalTranslationOffset\", label=\"Global Translation Offset\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputGlobalTranslationOffset\"), annotation=annotation)\n\n            self.addSeparator()\n\n            annotation = \"A rotation offset over the curve local space. This offset is initialized to the original object rotation. \"\n            self.addControl(\"inputLocalRotationOffset\", label=\"Local Rotation Offset\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputLocalRotationOffset\"), annotation=annotation)\n\n            annotation = \"A worldspace rotation offset.\"\n            self.addControl(\"inputGlobalRotationOffset\", label=\"Global Rotation Offset\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputGlobalRotationOffset\"), annotation=annotation)\n\n            self.addSeparator()\n\n            annotation = \"A scale offset over the object local space. This offset is initialized to the original object scale.\"\n            self.addControl(\"inputLocalScaleOffset\", label=\"Local Scale Offset\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputLocalScaleOffset\"), annotation=annotation)\n            \n            self.endLayout()\n\n            showRampControls(\"position\")\n            showRampControls(\"rotation\")\n            showRampControls(\"scale\")\n\n            self.beginLayout(\"Extra\", collapse=True)\n\n            # Additional info\n            annotation = \"The input object transform. DO NOT REMOVE THIS CONNECTION, or the node will stop working correctly.\"\n            self.addControl(\"inputTransformMatrix\", label=\"Input object\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputTransformMatrix\"), annotation=annotation)\n\n            annotation = \"The shading group for the instances. When instantiating, they will be assigned this SG.\"\n            self.addControl(\"inputShadingGroup\", label=\"Shading Group\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputShadingGroup\"), annotation=annotation)\n\n            self.endLayout()\n\n            self.endScrollLayout()\n\n    def showTitle(self):\n        pm.text(\"Instance Along Curve v\" + kPluginVersion, font=\"boldLabelFont\")\n\n    def buttonNew(self, nodeName):\n\n        # pm.separator( height=5, style='none')\n        pm.rowLayout(numberOfColumns=3, adjustableColumn=1, columnWidth3=(80, 100, 100))\n\n        self.updateManipButton = pm.button( label='Edit Manipulators...', command=lambda *args: self.onEditManipulators(nodeName))\n        self.updateManipButton.setAnnotation(\"When pressed, the manipulators will be selected. If the manipulator count changed, it will be updated.\")\n\n        self.resetPositionsButton = pm.button( label='Reset Positions', command=lambda *args: self.onResetManipPositions(nodeName))\n        self.resetPositionsButton.setAnnotation(\"When pressed, the manipulators will be uniformly distributed over the curve.\")\n\n        self.resetAnglesButton = pm.button( label='Reset Angles', command=lambda *args: self.onResetManipAngles(nodeName))\n        self.resetAnglesButton.setAnnotation(\"When pressed, all the manipulator angles will be reset to 0.\")\n    \n    def buttonUpdate(self, attr):\n\n        nodeName = pm.PyNode(attr).nodeName()\n        self.updateManipButton.setCommand(lambda *args: self.onEditManipulators(nodeName))\n        self.resetPositionsButton.setCommand(lambda *args: self.onResetManipPositions(nodeName))\n        self.resetAnglesButton.setCommand(lambda *args: self.onResetManipAngles(nodeName))\n    \n    def onResetManipPositions(self, nodeName):\n\n        # First, show manips to update manip count\n        self.onEditManipulators(nodeName)\n        res = pm.confirmDialog( title='Confirm reset positions', message='Are you sure you want to reset the manipulators positions?', button=['Yes','No'], defaultButton='Yes', cancelButton='No', dismissString='No' )\n\n        if res == \"Yes\":\n\n            pm.select( clear=True )\n\n            node = pm.PyNode(nodeName)\n            curve = node.inputCurve\n            handles = node.curveAxisHandle\n\n            if len(curve.connections()) == 1:\n\n                curveNode = curve.connections()[0]\n                maxParam = curveNode.findParamFromLength(curveNode.length())\n\n                count = min(node.curveAxisHandleCount.get(), handles.numElements())\n\n                index = 0\n                for h in handles:\n                    if index < count:\n                        h.children()[0].set(index * maxParam / float(count))\n                        index = index + 1\n                        \n                pm.select(nodeName)\n                pm.runtime.ShowManipulators()\n\n    def onResetManipAngles(self, nodeName):\n        \n        # First, show manips to update manip count\n        self.onEditManipulators(nodeName)\n        res = pm.confirmDialog( title='Confirm reset angles', message='Are you sure you want to reset the manipulators angles?', button=['Yes','No'], defaultButton='Yes', cancelButton='No', dismissString='No' )\n\n        if res == \"Yes\":\n\n            pm.select( clear=True )\n\n            node = pm.PyNode(nodeName)\n            handles = node.curveAxisHandle\n            count = min(node.curveAxisHandleCount.get(), handles.numElements())\n\n            index = 0\n            for h in handles:\n                if index < count:\n                    h.children()[1].set(0.0)\n                    index = index + 1\n\n            pm.select(nodeName)\n            pm.runtime.ShowManipulators()\n\n    def onEditManipulators(self, nodeName):\n        \n        # Unselect first, to trigger rebuilding of manips\n        pm.select( clear=True )\n        pm.select(nodeName)\n\n        pm.runtime.ShowManipulators()\n\n    # When orientation changes, update related controls...  \n    def updateOrientationChange(self, nodeName):\n        self.updateDimming(nodeName, \"orientationMode\")\n        self.updateManipCountDimming(nodeName)\n\n    def onRampUpdate(self, attr):\n        pm.gradientControl(attr)\n\n    def updateManipCountDimming(self, nodeName):\n\n        enableManips = pm.PyNode(nodeName).enableManipulators.get()\n\n        self.updateManipButton.setEnable(enableManips)\n        self.resetAnglesButton.setEnable(enableManips)\n        self.resetPositionsButton.setEnable(enableManips)        \n        self.updateDimming(nodeName, \"curveAxisHandleCount\", enableManips)\n\n    def updateDimming(self, nodeName, attr, additionalCondition = True):\n\n        if pm.PyNode(nodeName).type() == kPluginNodeName:\n\n            node = pm.PyNode(nodeName)\n            instanced = node.isInstanced()\n            hasInputTransform = node.inputTransform.isConnected() or node.inputTransformMatrix.isConnected()\n            hasInputCurve = node.inputCurve.isConnected()\n\n            self.dimControl(nodeName, attr, instanced or (not hasInputCurve) or (not hasInputTransform) or (not additionalCondition))\n\n    def onInstanceModeChanged(self, nodeName):\n        self.updateDimming(nodeName, \"instancingMode\")\n\n        if pm.PyNode(nodeName).type() == kPluginNodeName:\n\n            nodeAttr = pm.PyNode(nodeName + \".instancingMode\")\n            mode = nodeAttr.get(\"instancingMode\")\n\n            # If dimmed, do not update dimming\n            if mode == 0:\n                self.dimControl(nodeName, \"instanceLength\", True)\n                self.dimControl(nodeName, \"maxInstancesByLength\", True)\n\n                self.updateDimming(nodeName, \"instanceCount\")\n            else:\n                self.updateDimming(nodeName, \"instanceLength\")\n                self.updateDimming(nodeName, \"maxInstancesByLength\")\n                \n                self.dimControl(nodeName, \"instanceCount\", True)\n\n# Command\nclass instanceAlongCurveCommand(OpenMayaMPx.MPxCommand):\n\n    def __init__(self):\n        OpenMayaMPx.MPxCommand.__init__(self)\n        self.mUndo = []\n\n    def isUndoable(self):\n        return True\n\n    def undoIt(self): \n        OpenMaya.MGlobal.displayInfo( \"Undo: instanceAlongCurveCommand\\n\" )\n\n        # Reversed for undo :)\n        for m in reversed(self.mUndo):\n            m.undoIt()\n\n    def redoIt(self): \n        OpenMaya.MGlobal.displayInfo( \"Redo: instanceAlongCurveCommand\\n\" )\n        \n        for m in self.mUndo:\n            m.doIt()\n\n    def hasShapeBelow(self, dagPath):\n\n        sutil = OpenMaya.MScriptUtil()\n        uintptr = sutil.asUintPtr()\n        sutil.setUint(uintptr , 0)\n\n        dagPath.numberOfShapesDirectlyBelow(uintptr)\n\n        return sutil.getUint(uintptr) > 0\n\n    def findShadingGroup(self, dagPath):\n\n        # Search in children first before extending to shape\n        for child in xrange(dagPath.childCount()):\n            childDagPath = OpenMaya.MDagPath()\n            fnDagNode = OpenMaya.MFnDagNode(dagPath.child(child))\n            fnDagNode.getPath(childDagPath)\n\n            fnSet = self.findShadingGroup(childDagPath)\n\n            if fnSet is not None:\n                return fnSet\n\n        if self.hasShapeBelow(dagPath):\n            dagPath.extendToShape()\n            fnDepNode = OpenMaya.MFnDependencyNode(dagPath.node())\n\n            instPlugArray = fnDepNode.findPlug(\"instObjGroups\")\n            instPlugArrayElem = instPlugArray.elementByLogicalIndex(dagPath.instanceNumber())\n\n            if instPlugArrayElem.isConnected():\n                connectedPlugs = OpenMaya.MPlugArray()      \n                instPlugArrayElem.connectedTo(connectedPlugs, False, True)\n\n                if connectedPlugs.length() == 1:\n                    sgNode = connectedPlugs[0].node()\n\n                    if sgNode.hasFn(OpenMaya.MFn.kSet):\n                        return OpenMaya.MFnSet(sgNode)\n\n        return None\n        \n    def doIt(self,argList):\n        \n        try:\n            list = OpenMaya.MSelectionList()\n            OpenMaya.MGlobal.getActiveSelectionList(list)\n\n            if list.length() == 2:\n                curveDagPath = OpenMaya.MDagPath()\n                list.getDagPath(0, curveDagPath)\n                curveDagPath.extendToShape()\n\n                shapeDagPath = OpenMaya.MDagPath()\n                list.getDagPath(1, shapeDagPath)           \n\n                if(curveDagPath.node().hasFn(OpenMaya.MFn.kNurbsCurve)):\n\n                    # We need the curve transform\n                    curvePlug = OpenMaya.MFnDagNode(curveDagPath).findPlug(\"worldSpace\", False).elementByLogicalIndex(0)\n\n                    # We need the shape's transform too\n                    transformFn = OpenMaya.MFnDagNode(shapeDagPath.transform())\n                    transformMessagePlug = transformFn.findPlug(\"worldMatrix\", True)\n                    transformMessagePlug = transformMessagePlug.elementByLogicalIndex(0)\n\n                    shadingGroupFn = self.findShadingGroup(shapeDagPath)\n\n                    # Create node first\n                    mdagModifier = OpenMaya.MDagModifier()\n                    self.mUndo.append(mdagModifier)\n                    newNode = mdagModifier.createNode(kPluginNodeId)\n                    mdagModifier.doIt()\n\n                    # Assign new correct name and select new locator\n                    newNodeFn = OpenMaya.MFnDagNode(newNode)\n                    newNodeFn.setName(\"instanceAlongCurveLocator#\")\n                    newNodeTransformName = newNodeFn.name()\n\n                    # Get the node shape\n                    nodeShapeDagPath = OpenMaya.MDagPath()\n                    newNodeFn.getPath(nodeShapeDagPath)\n                    nodeShapeDagPath.extendToShape()\n                    newNodeFn = OpenMaya.MFnDagNode(nodeShapeDagPath)\n\n                    def setupRamp(rampAttr):\n\n                        # Set default ramp values\n                        defaultPositions = OpenMaya.MFloatArray(1, 0.0)\n                        defaultValues = OpenMaya.MFloatArray(1, 1.0)\n                        defaultInterpolations = OpenMaya.MIntArray(1, 3)\n\n                        plug = newNodeFn.findPlug(rampAttr.ramp)\n                        ramp = OpenMaya.MRampAttribute(plug)\n                        ramp.addEntries(defaultPositions, defaultValues, defaultInterpolations)\n\n                    setupRamp(instanceAlongCurveLocator.positionRampAttr)\n                    setupRamp(instanceAlongCurveLocator.rotationRampAttr)\n                    setupRamp(instanceAlongCurveLocator.scaleRampAttr)\n\n                    # Select new node shape\n                    OpenMaya.MGlobal.clearSelectionList()\n                    msel = OpenMaya.MSelectionList()\n                    msel.add(nodeShapeDagPath)\n                    OpenMaya.MGlobal.setActiveSelectionList(msel)\n\n                    # Connect :D\n                    mdagModifier = OpenMaya.MDagModifier()\n                    self.mUndo.append(mdagModifier)               \n                    mdagModifier.connect(curvePlug, newNodeFn.findPlug(instanceAlongCurveLocator.inputCurveAttr))\n                    mdagModifier.connect(transformMessagePlug, newNodeFn.findPlug(instanceAlongCurveLocator.inputTransformAttr))\n\n                    if shadingGroupFn is not None:\n                        shadingGroupMessagePlug = shadingGroupFn.findPlug(\"message\", True)\n                        mdagModifier.connect(shadingGroupMessagePlug, newNodeFn.findPlug(instanceAlongCurveLocator.inputShadingGroupAttr))\n\n                    mdagModifier.doIt()\n\n                    # (pymel) create a locator and make it the parent\n                    locator = pm.createNode('locator', ss=True, p=newNodeTransformName)\n\n                    # Show AE\n                    mel.eval(\"openAEWindow\")\n\n                    instanceCountPlug = newNodeFn.findPlug(\"instanceCount\", False)\n                    instanceCountPlug.setInt(10)\n\n                    # Rotation offset initialized to original rotation\n                    rotX = transformFn.findPlug(\"rotateX\", False).asMAngle().asDegrees()\n                    rotY = transformFn.findPlug(\"rotateY\", False).asMAngle().asDegrees()\n                    rotZ = transformFn.findPlug(\"rotateZ\", False).asMAngle().asDegrees()\n\n                    plugOffsetX = newNodeFn.findPlug(\"inputLocalRotationOffsetX\", False)\n                    plugOffsetY = newNodeFn.findPlug(\"inputLocalRotationOffsetY\", False)\n                    plugOffsetZ = newNodeFn.findPlug(\"inputLocalRotationOffsetZ\", False)\n\n                    plugOffsetX.setDouble(rotX)\n                    plugOffsetY.setDouble(rotY)\n                    plugOffsetZ.setDouble(rotZ)\n\n                    # Scale offset initialized to original scale\n                    scaleX = transformFn.findPlug(\"scaleX\", False).asFloat()\n                    scaleY = transformFn.findPlug(\"scaleY\", False).asFloat()\n                    scaleZ = transformFn.findPlug(\"scaleZ\", False).asFloat()\n\n                    plugOffsetX = newNodeFn.findPlug(\"inputLocalScaleOffsetX\", False)\n                    plugOffsetY = newNodeFn.findPlug(\"inputLocalScaleOffsetY\", False)\n                    plugOffsetZ = newNodeFn.findPlug(\"inputLocalScaleOffsetZ\", False)\n\n                    plugOffsetX.setDouble(scaleX)\n                    plugOffsetY.setDouble(scaleY)\n                    plugOffsetZ.setDouble(scaleZ)\n                    \n                else:\n                    sys.stderr.write(\"Please select a curve first\")\n            else:\n                sys.stderr.write(\"Please select a curve and a shape\")\n        except:\n            sys.stderr.write('Failed trying to create locator. stack trace: \\n')\n            sys.stderr.write(traceback.format_exc())\n\n    @staticmethod\n    def cmdCreator():\n        return OpenMayaMPx.asMPxPtr( instanceAlongCurveCommand() )\n\nclass instanceAlongCurveLocatorManip(OpenMayaMPx.MPxManipContainer):\n\n    def __init__(self):\n        OpenMayaMPx.MPxManipContainer.__init__(self)\n        self.nodeFn = OpenMaya.MFnDependencyNode()\n\n    @staticmethod\n    def nodeCreator():\n        return OpenMayaMPx.asMPxPtr( instanceAlongCurveLocatorManip() )\n\n    @staticmethod\n    def nodeInitializer():\n        OpenMayaMPx.MPxManipContainer.initialize()\n\n    def createChildren(self):\n\n        # List of tuples\n        self.manipCount = 0\n        self.manipHandleList = []\n        self.manipIndexCallbacks = {}\n\n        selectedObjects = OpenMaya.MSelectionList()\n        OpenMaya.MGlobal.getActiveSelectionList(selectedObjects)\n\n        # Because we need to know the selected object to manipulate, we cannot manipulate various nodes at once...\n        if selectedObjects.length() != 1:\n            return None\n\n        dagPath = OpenMaya.MDagPath()\n        selectedObjects.getDagPath(0, dagPath)\n        dagPath.extendToShape()\n\n        nodeFn = OpenMaya.MFnDependencyNode(dagPath.node())\n        enableManipulators = nodeFn.findPlug(instanceAlongCurveLocator.enableManipulatorsAttr).asBool()\n\n        # If the node is not using the custom rotation, prevent the user from breaking it ;)\n        if not enableManipulators:\n            return None\n\n        self.manipCount = nodeFn.findPlug(instanceAlongCurveLocator.curveAxisHandleCountAttr).asInt()\n\n        for i in xrange(self.manipCount):\n            pointOnCurveManip = self.addPointOnCurveManip(\"pointCurveManip\" + str(i), \"pointCurve\" + str(i))\n            discManip = self.addDiscManip(\"discManip\" + str(i), \"disc\" + str(i))\n            self.manipHandleList.append((pointOnCurveManip, discManip))\n\n    def getSortedCurveAxisArrayFromPlug(self, nodeFn, count):\n\n        axisHandles = []\n        plugArray = nodeFn.findPlug(instanceAlongCurveLocator.curveAxisHandleAttr.compound)\n\n        for i in xrange(count):\n            plug = plugArray.elementByLogicalIndex(i)\n            parameterPlug = plug.child(instanceAlongCurveLocator.curveAxisHandleAttr.parameter)\n            anglePlug = plug.child(instanceAlongCurveLocator.curveAxisHandleAttr.angle)\n\n            axisHandles.append((i, parameterPlug.asDouble(), anglePlug.asDouble()))\n\n        def getKey(item):\n            return item[1]\n\n        return sorted(axisHandles, key=getKey)\n\n    def connectToDependNode(self, node):\n\n        try:\n            self.nodeFn = OpenMaya.MFnDependencyNode(node)\n            curvePlug = self.nodeFn.findPlug(instanceAlongCurveLocator.inputCurveAttr)        \n            curveAxisHandleArrayPlug = self.nodeFn.findPlug(instanceAlongCurveLocator.curveAxisHandleAttr.compound)\n\n            self.curveFn = OpenMaya.MFnNurbsCurve(getFnFromPlug(curvePlug, OpenMaya.MFn.kNurbsCurve))\n            maxParam = self.curveFn.findParamFromLength(self.curveFn.length())\n\n            if self.manipCount == 0:\n                return None\n\n            handleCountPlug = self.nodeFn.findPlug(instanceAlongCurveLocator.curveAxisHandleCountAttr)\n            expectedHandleCount = handleCountPlug.asInt()\n            actualHandleCount = curveAxisHandleArrayPlug.numElements()\n            axisHandlesSorted = self.getSortedCurveAxisArrayFromPlug(self.nodeFn, actualHandleCount)\n\n            # Amount of new handles\n            handlesToInit = self.manipCount - actualHandleCount\n            handlesPerSegment = 0\n\n            if actualHandleCount > 0:\n                handlesPerSegment = max(math.ceil(handlesToInit / float(actualHandleCount)), 1)\n\n            # Build and connect all plugs\n            # Note: Previous plugs are still with remnant values (newHandleCount < oldHandleCount),\n            # but because when interpolating we just read the handle count attr, it works.\n            for i in xrange(self.manipCount):\n\n                # Handle data\n                curveAxisHandlePlug = curveAxisHandleArrayPlug.elementByLogicalIndex(i)\n                curveParameterPlug = curveAxisHandlePlug.child(instanceAlongCurveLocator.curveAxisHandleAttr.parameter)\n                curveAnglePlug = curveAxisHandlePlug.child(instanceAlongCurveLocator.curveAxisHandleAttr.angle)\n\n                fnCurvePoint = OpenMayaUI.MFnPointOnCurveManip(self.manipHandleList[i][0])\n                fnCurvePoint.connectToCurvePlug(curvePlug)\n                fnCurvePoint.connectToParamPlug(curveParameterPlug)\n                \n                # If we are adding a new handle, we should initialize this handle to some reasonable param/rotation\n                # Otherwise, just keep the previous handle data... it seems the most usable solution\n                if i >= actualHandleCount:\n\n                    if actualHandleCount > 1:\n\n                        # We distribute these new handles over existing segments, so try to distribute them evenly\n                        handleSegmentIndex = (i - actualHandleCount) % actualHandleCount\n                        handleEndSegmendIndex = (handleSegmentIndex + 1) % actualHandleCount\n                        handleSegmentSubIndex = (i - actualHandleCount) / actualHandleCount\n\n                        pT = float(handleSegmentSubIndex + 1) / float(handlesPerSegment + 1)\n                        pFrom = axisHandlesSorted[handleSegmentIndex][1]\n                        pTo = axisHandlesSorted[handleEndSegmendIndex][1]\n\n                        angleFrom = axisHandlesSorted[handleSegmentIndex][2]\n                        angleTo = axisHandlesSorted[handleEndSegmendIndex][2]\n\n                        # Wrap around in last segment\n                        if handleSegmentIndex + 1 >= actualHandleCount:\n                            pTo += maxParam\n                        \n                        # Interpolate both parameters and angle...\n                        lerpP = pFrom + (pTo - pFrom) * pT\n                        lerpAngle = angleFrom + (angleTo - angleFrom)  * pT\n\n                        curveParameterPlug.setFloat(lerpP)\n                        curveAnglePlug.setDouble(lerpAngle)\n\n                    else:\n                        # Default case... just add them over the curve\n                        curveParameterPlug.setFloat(self.curveFn.findParamFromLength(self.curveFn.length() * float(i) / float(self.manipCount)))\n\n                fnDisc = OpenMayaUI.MFnDiscManip(self.manipHandleList[i][1])\n                fnDisc.connectToAnglePlug(curveAnglePlug)\n                discCenterIndex = fnDisc.centerIndex()\n                discAxisIndex = fnDisc.axisIndex()\n\n                self.addPlugToManipConversion(discCenterIndex)\n                self.addPlugToManipConversion(discAxisIndex)\n\n                self.manipIndexCallbacks[discCenterIndex] = (self.discCenterConversion, i) # Store index value\n                self.manipIndexCallbacks[discAxisIndex] = (self.discAxisConversion, i) # Store index value\n\n            self.finishAddingManips()        \n            OpenMayaMPx.MPxManipContainer.connectToDependNode(self, node)\n\n        except:    \n            sys.stderr.write('Failed trying to connect manipulators. Stack trace: \\n')\n            sys.stderr.write(traceback.format_exc())\n\n    def discAxisConversion(self, manipTuple):\n\n        fnCurvePoint = OpenMayaUI.MFnPointOnCurveManip(manipTuple[0])        \n        param = fnCurvePoint.parameter()\n\n        tangent = self.curveFn.tangent(param, OpenMaya.MSpace.kWorld)\n\n        numData = OpenMaya.MFnNumericData()\n        numDataObj = numData.create(OpenMaya.MFnNumericData.k3Double)\n        numData.setData3Double(tangent.x, tangent.y, tangent.z)\n        manipData = OpenMayaUI.MManipData(numDataObj)\n        return manipData\n\n    def discCenterConversion(self, manipTuple):\n\n        fnCurvePoint = OpenMayaUI.MFnPointOnCurveManip(manipTuple[0])\n        center = fnCurvePoint.curvePoint()\n\n        numData = OpenMaya.MFnNumericData()\n        numDataObj = numData.create(OpenMaya.MFnNumericData.k3Double)\n        numData.setData3Double(center.x, center.y, center.z)\n        manipData = OpenMayaUI.MManipData(numDataObj)\n        return manipData\n\n    def plugToManipConversion(self, manipIndex):\n\n        if manipIndex in self.manipIndexCallbacks:\n            curveHandleIndex = self.manipIndexCallbacks[manipIndex][1]\n            return self.manipIndexCallbacks[manipIndex][0](self.manipHandleList[curveHandleIndex])\n\n        print \"Manip callback not set; returning invalid data!\"\n\n        numData = OpenMaya.MFnNumericData()\n        numDataObj = numData.create(OpenMaya.MFnNumericData.k3Double)\n        numData.setData3Double(0.0, 0.0, 0.0)\n        manipData = OpenMayaUI.MManipData(numDataObj)\n        return manipData\n\ndef initializePlugin( mobject ):\n    mplugin = OpenMayaMPx.MFnPlugin( mobject, \"mmerchante\", kPluginVersion )\n    try:\n        if (OpenMaya.MGlobal.mayaState() != OpenMaya.MGlobal.kBatch) and (OpenMaya.MGlobal.mayaState() != OpenMaya.MGlobal.kLibraryApp):\n            \n            # Register command\n            mplugin.registerCommand( kPluginCmdName, instanceAlongCurveCommand.cmdCreator )\n\n            mplugin.addMenuItem(\"Instance Along Curve\", \"MayaWindow|mainEditMenu\", kPluginCmdName, \"\")\n\n            # Register AE template\n            pm.callbacks(addCallback=loadAETemplateCallback, hook='AETemplateCustomContent', owner=kPluginNodeName)\n\n            # Register IAC manip node\n            mplugin.registerNode( kPluginManipNodeName, kPluginNodeManipId, instanceAlongCurveLocatorManip.nodeCreator, instanceAlongCurveLocatorManip.nodeInitializer, OpenMayaMPx.MPxNode.kManipContainer )\n\n        # Register IAC node\n        mplugin.registerNode( kPluginNodeName, kPluginNodeId, instanceAlongCurveLocator.nodeCreator,\n                              instanceAlongCurveLocator.nodeInitializer, OpenMayaMPx.MPxNode.kLocatorNode, kPluginNodeClassify )\n\n    except:\n        sys.stderr.write('Failed to register plugin instanceAlongCurve. stack trace: \\n')\n        sys.stderr.write(traceback.format_exc())\n        raise\n    \ndef uninitializePlugin( mobject ):\n    mplugin = OpenMayaMPx.MFnPlugin( mobject )\n    try:\n        mplugin.deregisterNode( kPluginNodeId )\n\n        if (OpenMaya.MGlobal.mayaState() != OpenMaya.MGlobal.kBatch) and (OpenMaya.MGlobal.mayaState() != OpenMaya.MGlobal.kLibraryApp):\n            mplugin.deregisterCommand( kPluginCmdName )\n            mplugin.deregisterNode( kPluginNodeManipId )\n    except:\n        sys.stderr.write( 'Failed to deregister plugin instanceAlongCurve')\n        raise\n\n### UTILS\ndef getSingleSourceObjectFromPlug(plug):\n\n    if plug.isConnected():\n        # Get connected input plugs\n        connections = OpenMaya.MPlugArray()\n        plug.connectedTo(connections, True, False)\n\n        # Find input transform\n        if connections.length() == 1:\n            return connections[0].node()\n\n    return None\n\ndef getFnFromPlug(plug, fnType):\n    node = getSingleSourceObjectFromPlug(plug)\n\n    # Get Fn from a DAG path to get the world transformations correctly\n    if node is not None:\n        path = OpenMaya.MDagPath()\n        trFn = OpenMaya.MFnDagNode(node)\n        trFn.getPath(path)\n\n        path.extendToShape()\n\n        if path.node().hasFn(fnType):\n            return path\n\n    return None\n\n# TODO: cache this data to prevent recalculating when there is no manipulator being updated\ndef getSortedCurveAxisArray(mObject, curveAxisHandleArray, count):\n    axisHandles = []\n\n    expectedHandleCount = OpenMaya.MFnDependencyNode(mObject).findPlug(instanceAlongCurveLocator.curveAxisHandleCountAttr).asInt()\n\n    for i in xrange(min(expectedHandleCount, curveAxisHandleArray.elementCount())):\n        curveAxisHandleArray.jumpToArrayElement(i)\n        parameterHandle = curveAxisHandleArray.inputValue().child(instanceAlongCurveLocator.curveAxisHandleAttr.parameter)\n        angleHandle = curveAxisHandleArray.inputValue().child(instanceAlongCurveLocator.curveAxisHandleAttr.angle)\n        axisHandles.append((i, parameterHandle.asDouble(), angleHandle.asDouble()))\n\n    def getKey(item):\n        return item[1]\n\n    return sorted(axisHandles, key=getKey)\n\ndef printVector(v, s=None):\n    print s + \":\" + str(v.x) + \", \" + str(v.y) + \", \" + str(v.z)\n" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Instance" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Instance" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "pythonFamily.png" 
        -image1 "pythonFamily.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "import sys\nimport math\nimport random\nimport traceback\nimport maya.mel as mel\nimport pymel.core as pm\nimport maya.OpenMaya as OpenMaya\nimport maya.OpenMayaUI as OpenMayaUI\nimport maya.OpenMayaMPx as OpenMayaMPx\nimport maya.OpenMayaRender as OpenMayaRender\n\nkPluginVersion = \"1.1.0\"\nkPluginCmdName = \"instanceAlongCurve\"\nkPluginCtxCmdName = \"instanceAlongCurveCtx\"\nkPluginNodeName = 'instanceAlongCurveLocator'\nkPluginManipNodeName = 'instanceAlongCurveLocatorManip'\nkPluginNodeClassify = 'utility/general'\nkPluginNodeId = OpenMaya.MTypeId( 0x55555 ) \nkPluginNodeManipId = OpenMaya.MTypeId( 0x55556 ) \n\nclass instanceAlongCurveLocator(OpenMayaMPx.MPxLocatorNode):\n\n    # Simple container class for compound vector attributes\n    class Vector3CompoundAttribute(object):\n\n        def __init__(self):            \n            self.compound = OpenMaya.MObject()\n            self.x = OpenMaya.MObject()\n            self.y = OpenMaya.MObject()\n            self.z = OpenMaya.MObject()\n\n    class CurveAxisHandleAttribute(object):\n\n        def __init__(self):\n            self.compound = OpenMaya.MObject()\n            self.parameter = OpenMaya.MObject()\n            self.angle = OpenMaya.MObject() # The angle over the tangent axis\n\n    # Legacy attributes to support backward compatibility\n    legacyInputTransformAttr = OpenMaya.MObject()\n\n    # Input attributes\n    inputCurveAttr = OpenMaya.MObject()\n    inputTransformAttr = OpenMaya.MObject()\n    inputShadingGroupAttr = OpenMaya.MObject()\n\n    # Translation offsets\n    inputLocalTranslationOffsetAttr = OpenMaya.MObject()\n    inputGlobalTranslationOffsetAttr = OpenMaya.MObject()\n\n    # Rotation offsets\n    inputLocalRotationOffsetAttr = OpenMaya.MObject()\n    inputGlobalRotationOffsetAttr = OpenMaya.MObject()\n\n    # Scale offset\n    inputLocalScaleOffsetAttr = OpenMaya.MObject()\n\n    # Instance count related attributes\n    instanceCountAttr = OpenMaya.MObject()\n    instancingModeAttr = OpenMaya.MObject()\n    instanceLengthAttr = OpenMaya.MObject()\n    maxInstancesByLengthAttr = OpenMaya.MObject()\n\n    # Curve axis data, to be manipulated by user\n    enableManipulatorsAttr = OpenMaya.MObject()\n    curveAxisHandleAttr = CurveAxisHandleAttribute()\n    curveAxisHandleCountAttr = OpenMaya.MObject()\n\n    displayTypeAttr = OpenMaya.MObject()\n    bboxAttr = OpenMaya.MObject()\n\n    orientationModeAttr = OpenMaya.MObject()\n    inputLocalOrientationAxisAttr = OpenMaya.MObject()\n\n    class RampAttributes(object):\n\n        def __init__(self):\n            self.ramp = OpenMaya.MObject() # normalized ramp\n            self.rampOffset = OpenMaya.MObject() # evaluation offset for ramp\n            self.rampAxis = OpenMaya.MObject() # ramp normalized axis\n            self.rampAmplitude = OpenMaya.MObject() # ramp amplitude\n            self.rampRandomAmplitude = OpenMaya.MObject() # ramp random amplitude\n            self.rampRepeat = OpenMaya.MObject()\n\n    # Simple container class for compound vector attributes\n    class RampValueContainer(object):\n\n        def __init__(self, mObject, dataBlock, rampAttr, normalize, instanceCount):            \n            self.ramp = OpenMaya.MRampAttribute(OpenMaya.MPlug(mObject, rampAttr.ramp))\n            self.rampOffset = dataBlock.inputValue(rampAttr.rampOffset).asFloat()\n            self.rampRandomAmplitude = dataBlock.inputValue(rampAttr.rampRandomAmplitude).asFloat()\n            self.rampAmplitude = dataBlock.inputValue(rampAttr.rampAmplitude).asFloat()\n            self.rampRepeat = dataBlock.inputValue(rampAttr.rampRepeat).asFloat()\n\n            if normalize:\n                self.rampAxis = dataBlock.inputValue(rampAttr.rampAxis.compound).asVector().normal()\n            else:\n                self.rampAxis = dataBlock.inputValue(rampAttr.rampAxis.compound).asVector()\n\n            self.useDynamicAmplitudeValues = False\n\n            amplitudePlug = OpenMaya.MPlug(mObject, rampAttr.rampAmplitude)\n\n            if amplitudePlug.isConnected():\n\n                # Get connected input plugs\n                connections = OpenMaya.MPlugArray()\n                amplitudePlug.connectedTo(connections, True, False)\n\n                # Find input transform\n                if connections.length() == 1:\n                    node = connections[0].node()\n                    nodeFn = OpenMaya.MFnDependencyNode(node)\n\n                    resultColors = OpenMaya.MFloatVectorArray()\n                    resultTransparencies = OpenMaya.MFloatVectorArray()\n\n                    uValues = OpenMaya.MFloatArray(instanceCount, 0.0)\n                    vValues = OpenMaya.MFloatArray(instanceCount, 0.0)\n\n                    # Sample a line, for more user flexibility\n                    for i in xrange(instanceCount):\n                        uValues.set(i / float(instanceCount), i)\n                        vValues.set(i / float(instanceCount), i)\n\n                    # For now... then we can just use the plug (TODO)\n                    if(node.hasFn(OpenMaya.MFn.kTexture2d)):                        \n                        \n                        OpenMayaRender.MRenderUtil.sampleShadingNetwork(nodeFn.name() + \".outColor\", instanceCount, False, False, OpenMaya.MFloatMatrix(), None, uValues, vValues, None, None, None, None, None, resultColors, resultTransparencies)\n\n                        self.rampAmplitudeValues = []\n                        self.useDynamicAmplitudeValues = True\n\n                        for i in xrange(resultColors.length()):\n                            self.rampAmplitudeValues.append(resultColors[i].length() / math.sqrt(3))\n\n    # Ramps base offset\n    distOffsetAttr = OpenMaya.MObject()\n\n    # Normalized thresholds for curve evaluation\n    curveStartAttr = OpenMaya.MObject()\n    curveEndAttr = OpenMaya.MObject()\n\n    # Ramp attributes\n    positionRampAttr = RampAttributes()\n    rotationRampAttr = RampAttributes()\n    scaleRampAttr = RampAttributes()\n\n    # Output vectors\n    outputTranslationAttr = Vector3CompoundAttribute()\n    outputRotationAttr = Vector3CompoundAttribute()\n    outputScaleAttr = Vector3CompoundAttribute()\n\n    def __init__(self):\n        OpenMayaMPx.MPxLocatorNode.__init__(self)\n\n    def postConstructor(self):\n        OpenMaya.MFnDependencyNode(self.thisMObject()).setName(\"instanceAlongCurveLocatorShape#\")\n        self.callbackId = OpenMaya.MNodeMessage.addAttributeChangedCallback(self.thisMObject(), self.attrChangeCallback)\n        self.updateInstanceConnections()\n\n    # Find original SG to reassign it to instance\n    def getShadingGroup(self):\n        inputSGPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.inputShadingGroupAttr)\n        sgNode = getSingleSourceObjectFromPlug(inputSGPlug)\n\n        if sgNode is not None and sgNode.hasFn(OpenMaya.MFn.kSet):\n            return OpenMaya.MFnSet(sgNode)\n\n        return None\n\n    def assignShadingGroup(self, fnDagNode):\n\n        fnSet = self.getShadingGroup()\n\n        if fnSet is not None:\n            # Easiest, cleanest way seems to be calling MEL.\n            # sets command handles everything, even nested instanced dag paths\n            mdgm = OpenMaya.MDGModifier()\n            mdgm.commandToExecute(\"sets -e -nw -fe \" + fnSet.name() + \" \" + fnDagNode.name())\n            mdgm.doIt()\n\n    # Helper function to get an array of available logical indices from the sparse array\n    # TODO: maybe it can be precalculated?\n    def getAvailableLogicalIndices(self, plug, numIndices):\n        \n        # Allocate and initialize\n        outIndices = OpenMaya.MIntArray(numIndices)\n        indices = OpenMaya.MIntArray(plug.numElements())\n        plug.getExistingArrayAttributeIndices(indices)\n\n        currentAvailableIndex = 0\n        indicesFound = 0\n\n        # Assuming indices are SORTED :)\n        for i in indices:\n\n            connectedPlug = plug.elementByLogicalIndex(i).isConnected()\n\n            # Iteratively find available indices in the sparse array\n            while i > currentAvailableIndex:\n                outIndices[indicesFound] = currentAvailableIndex\n                indicesFound += 1\n                currentAvailableIndex += 1\n\n            # Check against this index, add it if it is not connected\n            if i == currentAvailableIndex and not connectedPlug:\n                outIndices[indicesFound] = currentAvailableIndex\n                indicesFound += 1\n\n            currentAvailableIndex += 1\n\n            if indicesFound == numIndices:\n                return outIndices\n\n        # Fill remaining expected indices\n        for i in xrange(indicesFound, numIndices):\n            outIndices[i] = currentAvailableIndex\n            currentAvailableIndex += 1\n\n        return outIndices\n\n    def getNodeTransformFn(self):\n        dagNode = OpenMaya.MFnDagNode(self.thisMObject())\n        dagPath = OpenMaya.MDagPath()\n        dagNode.getPath(dagPath)\n        return OpenMaya.MFnDagNode(dagPath.transform())\n\n    def updateInstanceConnections(self):\n\n        # If the locator is being instanced, just stop updating its children.\n        # This is to prevent losing references to the locator instances' children\n        # If you want to change this locator, prepare the source before instantiating\n        if OpenMaya.MFnDagNode(self.thisMObject()).isInstanced():\n            return OpenMaya.kUnknownParameter\n\n        # Plugs\n        outputTranslationPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.outputTranslationAttr.compound)\n        outputRotationPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.outputRotationAttr.compound)\n        outputScalePlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.outputScaleAttr.compound)\n\n        expectedInstanceCount = self.getInstanceCountByMode()\n        numConnectedElements = outputTranslationPlug.numConnectedElements()\n\n        # Only instance if we are missing elements\n        # TODO: handle mismatches in translation/rotation plug connected elements (user deleted a plug? use connectionBroken method?)\n        if numConnectedElements < expectedInstanceCount:\n\n            inputTransformFn = self.getInputTransformFn()\n\n            if inputTransformFn is not None:\n\n                rotatePivot = inputTransformFn.rotatePivot(OpenMaya.MSpace.kTransform )\n                scalePivot = inputTransformFn.scalePivot(OpenMaya.MSpace.kTransform )\n\n                transformFn = self.getNodeTransformFn()\n                newInstancesCount = expectedInstanceCount - numConnectedElements\n                availableIndices = self.getAvailableLogicalIndices(outputTranslationPlug, newInstancesCount)\n\n                displayPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.displayTypeAttr)\n                LODPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.bboxAttr)\n\n                mdgModifier = OpenMaya.MDagModifier()\n\n                for i in availableIndices:\n                    \n                    # Instance transform\n                    # InstanceLeaf must be set to False to prevent crashes :)\n                    trInstance = inputTransformFn.duplicate(True, False)\n                    instanceFn = OpenMaya.MFnTransform(trInstance)\n\n                    # Parent new instance\n                    transformFn.addChild(trInstance)\n\n                    # Pivots\n                    instanceFn.setRotatePivot(rotatePivot, OpenMaya.MSpace.kTransform , False)\n                    instanceFn.setScalePivot(scalePivot, OpenMaya.MSpace.kTransform , False)\n\n                    instanceTranslatePlug = instanceFn.findPlug('translate', False)\n                    outputTranslationPlugElement = outputTranslationPlug.elementByLogicalIndex(i)\n\n                    instanceRotationPlug = instanceFn.findPlug('rotate', False)\n                    outputRotationPlugElement = outputRotationPlug.elementByLogicalIndex(i)\n\n                    instanceScalePlug = instanceFn.findPlug('scale', False)\n                    outputScalePlugElement = outputScalePlug.elementByLogicalIndex(i)\n\n                    # Make instance visible\n                    instanceFn.findPlug(\"visibility\", False).setBool(True)\n\n                    # Enable drawing overrides\n                    overrideEnabledPlug = instanceFn.findPlug(\"overrideEnabled\", False)\n                    overrideEnabledPlug.setBool(True)\n\n                    instanceDisplayPlug = instanceFn.findPlug(\"overrideDisplayType\", False)\n                    instanceLODPlug = instanceFn.findPlug(\"overrideLevelOfDetail\", False)\n\n                    if not outputTranslationPlugElement.isConnected():\n                        mdgModifier.connect(outputTranslationPlugElement, instanceTranslatePlug)\n\n                    if not outputRotationPlugElement.isConnected():\n                        mdgModifier.connect(outputRotationPlugElement, instanceRotationPlug)\n\n                    if not outputScalePlugElement.isConnected():\n                        mdgModifier.connect(outputScalePlugElement, instanceScalePlug)\n\n                    if not instanceDisplayPlug.isConnected():\n                        mdgModifier.connect(displayPlug, instanceDisplayPlug)\n\n                    if not instanceLODPlug.isConnected():\n                        mdgModifier.connect(LODPlug, instanceLODPlug)\n\n                mdgModifier.doIt()\n\n                # Finally, assign SG to all children\n                self.assignShadingGroup(transformFn)\n\n        # Remove instances if necessary\n        elif numConnectedElements > expectedInstanceCount:\n\n            connections = OpenMaya.MPlugArray()        \n            toRemove = numConnectedElements - expectedInstanceCount\n            mdgModifier = OpenMaya.MDGModifier()\n\n            for i in xrange(toRemove):\n                outputTranslationPlugElement = outputTranslationPlug.connectionByPhysicalIndex(numConnectedElements - 1 - i)\n                outputTranslationPlugElement.connectedTo(connections, False, True)\n\n                for c in xrange(connections.length()):\n                    mdgModifier.deleteNode(connections[c].node())\n\n            mdgModifier.doIt()\n\n    def attrChangeCallback(self, msg, plug, otherPlug, clientData):\n\n        incomingDirection = (OpenMaya.MNodeMessage.kIncomingDirection & msg) == OpenMaya.MNodeMessage.kIncomingDirection\n        attributeSet = (OpenMaya.MNodeMessage.kAttributeSet & msg) == OpenMaya.MNodeMessage.kAttributeSet\n        isCorrectAttribute = (plug.attribute() == instanceAlongCurveLocator.instanceCountAttr) \n        isCorrectAttribute = isCorrectAttribute or (plug.attribute() == instanceAlongCurveLocator.instancingModeAttr)\n        isCorrectAttribute = isCorrectAttribute or (plug.attribute() == instanceAlongCurveLocator.instanceLengthAttr)\n        isCorrectAttribute = isCorrectAttribute or (plug.attribute() == instanceAlongCurveLocator.maxInstancesByLengthAttr)\n        isCorrectAttribute = isCorrectAttribute or (plug.attribute() == instanceAlongCurveLocator.curveStartAttr)\n        isCorrectAttribute = isCorrectAttribute or (plug.attribute() == instanceAlongCurveLocator.curveEndAttr)\n\n        isCorrectNode = OpenMaya.MFnDependencyNode(plug.node()).typeName() == kPluginNodeName\n\n        try:\n            if isCorrectNode and isCorrectAttribute and attributeSet and incomingDirection:\n                self.updateInstanceConnections()\n        except:    \n            sys.stderr.write('Failed trying to update instances. stack trace: \\n')\n            sys.stderr.write(traceback.format_exc())\n\n    def getInputTransformPlug(self):\n\n        # Backward compatibility\n        inputTransformPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.inputTransformAttr)\n        legacyInputTransformPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.legacyInputTransformAttr)\n\n        if(legacyInputTransformPlug.isConnected()):\n            inputTransformPlug = legacyInputTransformPlug\n\n        return inputTransformPlug\n\n    def getInputTransformFn(self):\n\n        inputTransformPlug = self.getInputTransformPlug()\n        transform = getSingleSourceObjectFromPlug(inputTransformPlug)\n\n        # Get Fn from a DAG path to get the world transformations correctly\n        if transform is not None and transform.hasFn(OpenMaya.MFn.kTransform):\n                path = OpenMaya.MDagPath()\n                trFn = OpenMaya.MFnDagNode(transform)\n                trFn.getPath(path)\n                return OpenMaya.MFnTransform(path)\n\n        return None\n\n    def getCurveFn(self):\n        inputCurvePlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.inputCurveAttr)\n        curve = getSingleSourceObjectFromPlug(inputCurvePlug)\n\n        # Get Fn from a DAG path to get the world transformations correctly\n        if curve is not None:\n            path = OpenMaya.MDagPath()\n            trFn = OpenMaya.MFnDagNode(curve)\n            trFn.getPath(path)\n\n            path.extendToShape()\n\n            if path.node().hasFn(OpenMaya.MFn.kNurbsCurve):\n                return OpenMaya.MFnNurbsCurve(path)\n\n        return None\n\n    # Calculate expected instances by the instancing mode\n    def getInstanceCountByMode(self):\n        instancingModePlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.instancingModeAttr)\n        inputCurvePlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.inputCurveAttr)\n\n        if inputCurvePlug.isConnected() and instancingModePlug.asInt() == 1:\n            instanceLengthPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.instanceLengthAttr)\n            maxInstancesByLengthPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.maxInstancesByLengthAttr)\n            curveFn = self.getCurveFn()\n\n            # Known issue: even if the curve fn is dag path constructed, its length is not worldspace... \n            # If you want perfect distance-based instancing, freeze the transformations of the curve\n            curveLength = curveFn.length()\n\n            curveStart = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.curveStartAttr).asFloat() * curveLength\n            curveEnd = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.curveEndAttr).asFloat() * curveLength\n\n            effectiveCurveLength = min(max(curveEnd - curveStart, 0.001), curveLength)\n\n            return min(maxInstancesByLengthPlug.asInt(), int(math.ceil(effectiveCurveLength / instanceLengthPlug.asFloat())))\n\n        instanceCountPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.instanceCountAttr)\n        return instanceCountPlug.asInt()\n\n    def getRandomizedValueUnified(self, randomValue, randomAmplitude, value):\n        return (randomValue * 2.0 - 1.0) * randomAmplitude + value\n\n    def getRandomizedValue(self, random, randomAmplitude, value):\n        return (random.random() * 2.0 - 1.0) * randomAmplitude + value\n\n    # Calculate expected instances by the instancing mode\n    def getIncrementByMode(self, count, effectiveCurveLength):\n        instancingModePlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.instancingModeAttr)\n       \n        # Distance defined manually\n        if instancingModePlug.asInt() == 1:\n            instanceLengthPlug = OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.instanceLengthAttr)            \n            return instanceLengthPlug.asFloat()\n        \n        # Distance driven by count\n        return effectiveCurveLength / float(count)\n\n    def updateInstancePositions(self, curveFn, dataBlock, count, distOffset, curveStart, curveEnd, effectiveCurveLength, lengthIncrement, inputTransformPlug, inputTransformFn, axisHandlesSorted):\n\n            # Common data\n            translateArrayHandle = dataBlock.outputArrayValue(instanceAlongCurveLocator.outputTranslationAttr.compound)\n            curveLength = curveFn.length()\n            maxParam = curveFn.findParamFromLength(curveLength)\n            curveForm = curveFn.form()\n\n            # Important: enums are short! If not, the resulting int may be incorrect\n            rotMode = dataBlock.inputValue(instanceAlongCurveLocator.orientationModeAttr).asShort()\n            localRotationAxisMode = dataBlock.inputValue(instanceAlongCurveLocator.inputLocalOrientationAxisAttr).asShort()\n\n            if localRotationAxisMode == 0:\n                forward = OpenMaya.MVector.xAxis\n                up = OpenMaya.MVector.yAxis\n                right = OpenMaya.MVector.zAxis\n            elif localRotationAxisMode == 1:\n                forward = OpenMaya.MVector.yAxis\n                up = OpenMaya.MVector.zAxis\n                right = OpenMaya.MVector.xAxis\n            elif localRotationAxisMode == 2:\n                forward = OpenMaya.MVector.zAxis\n                up = OpenMaya.MVector.yAxis\n                right = OpenMaya.MVector.xAxis\n\n            # We use Z axis as forward, and adjust locally to that axis\n            referenceAxis = OpenMaya.MVector.zAxis\n            referenceUp = OpenMaya.MVector.yAxis\n\n            # Local offset is not considered for position\n            localRotation = forward.rotateTo(referenceAxis)\n\n            # Manipulator data\n            enableManipulators = dataBlock.inputValue(instanceAlongCurveLocator.enableManipulatorsAttr).asBool()\n\n            # Local translation offsets\n            localTranslationOffset = dataBlock.inputValue(instanceAlongCurveLocator.inputLocalTranslationOffsetAttr.compound).asVector()\n            globalTranslationOffset = dataBlock.inputValue(instanceAlongCurveLocator.inputGlobalTranslationOffsetAttr.compound).asVector()\n            \n            # Get pivot\n            rotatePivot = OpenMaya.MVector()\n\n            if inputTransformPlug.isConnected():\n                rotatePivot = OpenMaya.MVector(inputTransformFn.rotatePivot(OpenMaya.MSpace.kTransform ))\n                rotatePivot += OpenMaya.MVector(inputTransformFn.rotatePivotTranslation(OpenMaya.MSpace.kTransform ))\n\n            # Deterministic random\n            random.seed(count)\n            rampValues = instanceAlongCurveLocator.RampValueContainer(self.thisMObject(), dataBlock, instanceAlongCurveLocator.positionRampAttr, False, count)\n\n            inputTransformRotation = OpenMaya.MQuaternion()\n\n            # First, map parameter\n            if inputTransformPlug.isConnected():\n                inputTransformFn.getRotation(inputTransformRotation, OpenMaya.MSpace.kWorld)\n\n            # Make sure there are enough handles...\n            for i in xrange(min(count, translateArrayHandle.elementCount())):\n\n                dist = math.fmod(curveStart + math.fmod(lengthIncrement * i + distOffset, effectiveCurveLength), curveLength)\n                param = max( min( curveFn.findParamFromLength( dist ), maxParam ), 0.0)\n\n                # Ramps are not modified by curve start/end, so objects can \"slide\"\n                normalizedDistance = dist / curveFn.length()\n                rampValue = self.getRampValueAtNormalizedPosition(rampValues, normalizedDistance)\n                \n                # Get the actual point on the curve...\n                point = OpenMaya.MPoint()\n                curveFn.getPointAtParam(param, point)\n\n                tangent = curveFn.tangent(param)\n                rot = referenceAxis.rotateTo(tangent)\n\n                # If the axis is parallel, but with inverse direction, rotate it PI over the up vector\n                if referenceAxis.isParallel(tangent) and (referenceAxis * tangent < 0):\n                    rot = OpenMaya.MQuaternion(math.pi, referenceUp)\n\n                # Transform rotation so that it is aligned with the tangent. This fixes unintentional twisting\n                rot = localRotation * rot\n                \n                # Modify resulting rotation based on mode\n                if rotMode == 0:                    # Identity\n                    rot = OpenMaya.MQuaternion()\n                elif rotMode == 1:                  # Input rotation\n                    rot = inputTransformRotation;\n                elif rotMode == 3 and i % 2 == 1:   # Chain mode, interesting for position ;)\n                    rot *= OpenMaya.MQuaternion(math.pi * .5, tangent)\n\n                # Get the angle from handles, and rotate over tangent axis\n                if enableManipulators:\n                    angle = self.getRotationForParam(param, axisHandlesSorted, curveForm, maxParam)\n                    rot = rot * OpenMaya.MQuaternion(-angle, tangent)\n\n                # The curve basis used for twisting\n                basisForward = forward.rotateBy(rot)\n                basisUp = up.rotateBy(rot)\n                basisRight = right.rotateBy(rot)\n\n                rampAmplitude = self.getRampAmplitudeForInstance(rampValues, i)\n\n                twistNormal = basisRight * self.getRandomizedValue(random, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.x\n                twistTangent = basisUp * self.getRandomizedValue(random, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.y\n                twistBitangent = basisForward * self.getRandomizedValue(random, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.z\n\n                twist = (twistNormal + twistTangent + twistBitangent)\n\n                # Twist + global offset, without pivot\n                point += twist + globalTranslationOffset - rotatePivot\n\n                # Local offset\n                point += basisRight * localTranslationOffset.x + basisUp * localTranslationOffset.y + basisForward * localTranslationOffset.z\n\n                translateArrayHandle.jumpToArrayElement(i)\n                translateHandle = translateArrayHandle.outputValue()\n                translateHandle.set3Double(point.x, point.y, point.z)\n\n            translateArrayHandle.setAllClean()\n            translateArrayHandle.setClean()\n\n    def getRampAmplitudeForInstance(self, rampValues, instanceIndex):\n\n        if rampValues.useDynamicAmplitudeValues:\n\n            if len(rampValues.rampAmplitudeValues) > instanceIndex:\n                return rampValues.rampAmplitudeValues[instanceIndex]\n\n        return rampValues.rampAmplitude\n\n    def getRampValueAtNormalizedPosition(self, rampValues, v):\n\n        util = OpenMaya.MScriptUtil()\n        util.createFromDouble(0.0)\n        valuePtr = util.asFloatPtr()\n        \n        position = math.fmod((v * rampValues.rampRepeat) + rampValues.rampOffset, 1.0)\n        rampValues.ramp.getValueAtPosition(position, valuePtr)\n\n        return util.getFloat(valuePtr)\n\n    def updateInstanceScale(self, curveFn, dataBlock, count, distOffset, curveStart, curveEnd, effectiveCurveLength, lengthIncrement):\n\n            point = OpenMaya.MPoint()\n            curveLength = curveFn.length()\n            maxParam = curveFn.findParamFromLength(curveLength)\n            scaleArrayHandle = dataBlock.outputArrayValue(instanceAlongCurveLocator.outputScaleAttr.compound)\n\n            localScaleOffset = dataBlock.inputValue(instanceAlongCurveLocator.inputLocalScaleOffsetAttr.compound).asVector()\n\n            # Deterministic random\n            random.seed(count)\n            rampValues = instanceAlongCurveLocator.RampValueContainer(self.thisMObject(), dataBlock, instanceAlongCurveLocator.scaleRampAttr, False, count)\n\n            # Make sure there are enough handles...\n            for i in xrange(min(count, scaleArrayHandle.elementCount())):\n\n                dist = math.fmod(curveStart + math.fmod(lengthIncrement * i + distOffset, effectiveCurveLength), curveLength)\n                param = max( min( curveFn.findParamFromLength( dist ), maxParam ), 0.0)\n\n                # Ramps are not modified by curve start/end, so objects can \"slide\"\n                normalizedDistance = dist / curveFn.length()\n                rampValue = self.getRampValueAtNormalizedPosition(rampValues, normalizedDistance)\n\n                unifiedRandom = random.random()\n                rampAmplitude = self.getRampAmplitudeForInstance(rampValues, i)\n\n                # Scales are unified... because it makes more sense\n                point.x = localScaleOffset.x + self.getRandomizedValueUnified(unifiedRandom, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.x\n                point.y = localScaleOffset.y + self.getRandomizedValueUnified(unifiedRandom, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.y\n                point.z = localScaleOffset.z + self.getRandomizedValueUnified(unifiedRandom, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.z\n\n                scaleArrayHandle.jumpToArrayElement(i)\n                scaleHandle = scaleArrayHandle.outputValue()\n                scaleHandle.set3Double(point.x, point.y, point.z)\n\n            scaleArrayHandle.setAllClean()\n            scaleArrayHandle.setClean()\n\n    # TODO: cache this data to prevent recalculating when there is no manipulator being updated\n    def getRotationForParam(self, param, axisHandlesSorted, curveForm, curveMaxParam):\n\n        indexRange = (-1, -1)\n        wrapAround = not (curveForm is OpenMaya.MFnNurbsCurve.kOpen)\n\n        # Find the range of indices that make up this curve segment\n        for i in xrange(len(axisHandlesSorted)):\n\n            # TODO: could use a binary search\n            if param < axisHandlesSorted[i][1]:\n\n                if i > 0:\n                    indexRange = (i - 1, i)\n                    break\n                elif wrapAround:\n                    indexRange = (len(axisHandlesSorted) - 1, 0)\n                    break\n                else:\n                    indexRange = (0, 0)\n                    break\n\n        # Edge case\n        if indexRange[0] == -1 and indexRange[1] == -1 and len(axisHandlesSorted) > 0:\n            if wrapAround:\n                indexRange = (len(axisHandlesSorted) - 1, 0)\n            else:\n                indexRange = (len(axisHandlesSorted) - 1, len(axisHandlesSorted) - 1)\n            \n        # Now find the lerp value based on the range\n        if indexRange[0] > -1 and indexRange[1] > -1:\n            minParam = axisHandlesSorted[indexRange[0]][1]\n            maxParam = axisHandlesSorted[indexRange[1]][1]\n\n            minAxis = axisHandlesSorted[indexRange[0]][2]\n            maxAxis = axisHandlesSorted[indexRange[1]][2]\n\n            if(math.fabs(minParam - maxParam) > 0.001):\n\n                if minParam > maxParam and wrapAround:\n\n                    if param < maxParam:\n                        param = param + curveMaxParam\n\n                    maxParam = maxParam + curveMaxParam\n                \n                t = min(max((param - minParam) / (maxParam - minParam), 0.0), 1.0)\n\n                return minAxis + (maxAxis - minAxis) * t\n\n            return minAxis\n\n        return 0.0\n\n    def updateInstanceRotations(self, curveFn, dataBlock, count, distOffset, curveStart, curveEnd, effectiveCurveLength, lengthIncrement, inputTransformPlug, inputTransformFn, axisHandlesSorted):\n\n        # Common data\n        curveLength = curveFn.length()\n        maxParam = curveFn.findParamFromLength(curveLength)\n        curveForm = curveFn.form()\n        rotationArrayHandle = dataBlock.outputArrayValue(instanceAlongCurveLocator.outputRotationAttr.compound)\n\n        # All offsets are in degrees\n        localRotationOffset = dataBlock.inputValue(instanceAlongCurveLocator.inputLocalRotationOffsetAttr.compound).asVector() * math.radians(1)\n        globalRotationOffset = dataBlock.inputValue(instanceAlongCurveLocator.inputGlobalRotationOffsetAttr.compound).asVector() * math.radians(1)\n\n        localRotationOffset = OpenMaya.MEulerRotation(localRotationOffset.x, localRotationOffset.y, localRotationOffset.z).asQuaternion()\n        globalRotationOffset = OpenMaya.MEulerRotation(globalRotationOffset.x, globalRotationOffset.y, globalRotationOffset.z).asQuaternion()\n\n        # Important: enums are short! If not, the resulting int may be incorrect\n        rotMode = dataBlock.inputValue(instanceAlongCurveLocator.orientationModeAttr).asShort()\n        localRotationAxisMode = dataBlock.inputValue(instanceAlongCurveLocator.inputLocalOrientationAxisAttr).asShort()\n\n        if localRotationAxisMode == 0:\n            forward = OpenMaya.MVector.xAxis\n            up = OpenMaya.MVector.yAxis\n            right = OpenMaya.MVector.zAxis\n        elif localRotationAxisMode == 1:\n            forward = OpenMaya.MVector.yAxis\n            up = OpenMaya.MVector.zAxis\n            right = OpenMaya.MVector.xAxis\n        elif localRotationAxisMode == 2:\n            forward = OpenMaya.MVector.zAxis\n            up = OpenMaya.MVector.yAxis\n            right = OpenMaya.MVector.xAxis\n\n        # We use Z axis as forward, and adjust locally to that axis\n        referenceAxis = OpenMaya.MVector.zAxis\n        referenceUp = OpenMaya.MVector.yAxis\n\n        # Rotation to align selected (local) forward axis to the reference forward axis (which is aligned with tangent)\n        localRotation = localRotationOffset * forward.rotateTo(referenceAxis)\n\n        # Deterministic random\n        random.seed(count)\n        rampValues = instanceAlongCurveLocator.RampValueContainer(self.thisMObject(), dataBlock, instanceAlongCurveLocator.rotationRampAttr, True, count)\n\n        # Manipulator stuff\n        enableManipulators = dataBlock.inputValue(instanceAlongCurveLocator.enableManipulatorsAttr).asBool()\n\n        # Original transform data\n        inputTransformRotation = OpenMaya.MQuaternion()\n\n        # First, map parameter\n        if inputTransformPlug.isConnected():\n            inputTransformFn.getRotation(inputTransformRotation, OpenMaya.MSpace.kWorld)\n\n        for i in xrange(min(count, rotationArrayHandle.elementCount())):\n            \n            dist = math.fmod(curveStart + math.fmod(lengthIncrement * i + distOffset, effectiveCurveLength), curveLength)\n            param = max( min( curveFn.findParamFromLength( dist ), maxParam ), 0.0)\n\n            # Ramps are not modified by curve start/end, so objects can \"slide\"\n            normalizedDistance = dist / curveFn.length()\n            rampValue = self.getRampValueAtNormalizedPosition(rampValues, normalizedDistance)\n\n            tangent = curveFn.tangent(param)\n\n            # Reference axis (Z) is now aligned with tangent\n            rot = referenceAxis.rotateTo(tangent)\n\n            # If the axis is parallel, but with inverse direction, rotate it PI over the up vector\n            if referenceAxis.isParallel(tangent) and (referenceAxis * tangent < 0):\n                rot = OpenMaya.MQuaternion(math.pi, referenceUp)\n\n            # Rotate local axis to align with tangent\n            rot = localRotation * rot\n            \n            # The curve basis used for twisting        \n            basisForward = forward.rotateBy(rot)\n            basisUp = up.rotateBy(rot)\n            basisRight = right.rotateBy(rot)\n\n            rampAmplitude = self.getRampAmplitudeForInstance(rampValues, i)\n\n            twistNormal = self.getRandomizedValue(random, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.x                \n            twistNormal = OpenMaya.MQuaternion(math.radians(twistNormal), basisRight) #X\n\n            twistTangent = self.getRandomizedValue(random, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.y\n            twistTangent = OpenMaya.MQuaternion(math.radians(twistTangent), basisUp) #Y\n\n            twistBitangent = self.getRandomizedValue(random, rampValues.rampRandomAmplitude, rampValue * rampAmplitude) * rampValues.rampAxis.z\n            twistBitangent = OpenMaya.MQuaternion(math.radians(twistBitangent), basisForward) #Z\n\n            # Modify resulting rotation based on mode\n            if rotMode == 0:                    # Identity\n                rot = OpenMaya.MQuaternion()\n            elif rotMode == 1:                  # Input rotation\n                rot = inputTransformRotation;\n            elif rotMode == 3 and i % 2 == 1:   # Chain mode\n                rot *= OpenMaya.MQuaternion(math.pi * .5, tangent)\n\n            # Get the angle from handles, and rotate over tangent axis\n            if enableManipulators:\n                angle = self.getRotationForParam(param, axisHandlesSorted, curveForm, maxParam)\n                rot = rot * OpenMaya.MQuaternion(-angle, tangent)\n\n            rot = ((rot * twistNormal * twistTangent * twistBitangent) * globalRotationOffset).asEulerRotation().asVector()\n\n            rotationArrayHandle.jumpToArrayElement(i)\n            rotationHandle = rotationArrayHandle.outputValue()\n            rotationHandle.set3Double(rot.x, rot.y, rot.z)\n\n        rotationArrayHandle.setAllClean()\n        rotationArrayHandle.setClean()\n\n    def isBounded(self):\n        return True\n\n    def boundingBox(self):\n        return OpenMaya.MBoundingBox(OpenMaya.MPoint(-1,-1,-1), OpenMaya.MPoint(1,1,1))\n\n    def compute(self, plug, dataBlock):\n        try:\n            curveDataHandle = dataBlock.inputValue(instanceAlongCurveLocator.inputCurveAttr)\n            curve = curveDataHandle.asNurbsCurveTransformed()\n\n            updateTranslation = (plug == instanceAlongCurveLocator.outputTranslationAttr.compound)\n            updateRotation = (plug == instanceAlongCurveLocator.outputRotationAttr.compound)\n            updateScale = (plug == instanceAlongCurveLocator.outputScaleAttr.compound)\n\n            if not curve.isNull():\n\n                if updateTranslation or updateRotation or updateScale:\n                    curveFn = OpenMaya.MFnNurbsCurve(curve)\n\n                    instanceCount = self.getInstanceCountByMode()\n                    distOffset = dataBlock.inputValue(instanceAlongCurveLocator.distOffsetAttr).asFloat()\n                    curveLength = curveFn.length()\n\n                    # Curve thresholds\n                    curveStart = dataBlock.inputValue(instanceAlongCurveLocator.curveStartAttr).asFloat() * curveLength\n                    curveEnd = dataBlock.inputValue(instanceAlongCurveLocator.curveEndAttr).asFloat() * curveLength\n\n                    effectiveCurveLength = min(max(curveEnd - curveStart, 0.001), curveLength)\n                    lengthIncrement = self.getIncrementByMode(instanceCount, effectiveCurveLength)\n\n                    # Common data\n                    inputTransformPlug = self.getInputTransformPlug()\n                    inputTransformFn = self.getInputTransformFn()\n                    \n                    # Force update of transformation \n                    if OpenMaya.MPlug(self.thisMObject(), instanceAlongCurveLocator.inputTransformAttr).isConnected():\n                        dataBlock.inputValue(inputTransformPlug).asMatrix()\n\n                    # Manipulator data\n                    curveAxisHandleArray = dataBlock.inputArrayValue(instanceAlongCurveLocator.curveAxisHandleAttr.compound)\n                    axisHandlesSorted = getSortedCurveAxisArray(self.thisMObject(), curveAxisHandleArray, instanceCount)\n\n                    if updateTranslation:\n                        self.updateInstancePositions(curveFn, dataBlock, instanceCount, distOffset, curveStart, curveEnd, effectiveCurveLength, lengthIncrement, inputTransformPlug, inputTransformFn, axisHandlesSorted)\n\n                    if updateRotation:\n                        self.updateInstanceRotations(curveFn, dataBlock, instanceCount, distOffset, curveStart, curveEnd, effectiveCurveLength, lengthIncrement, inputTransformPlug, inputTransformFn, axisHandlesSorted)\n\n                    if updateScale:\n                        self.updateInstanceScale(curveFn, dataBlock, instanceCount, distOffset, curveStart, curveEnd, effectiveCurveLength, lengthIncrement)\n\n        except:\n            sys.stderr.write('Failed trying to compute locator. stack trace: \\n')\n            sys.stderr.write(traceback.format_exc())\n            return OpenMaya.kUnknownParameter\n\n    @staticmethod\n    def nodeCreator():\n        return OpenMayaMPx.asMPxPtr( instanceAlongCurveLocator() )\n\n    @classmethod\n    def addCompoundVector3Attribute(cls, compoundAttribute, attributeName, unitType, arrayAttr, inputAttr, defaultValue):\n\n        # Schematic view of compound attribute:\n        # compoundAttribute[?]\n        #   compoundAttributeX\n        #   compoundAttributeY\n        #   compoundAttributeZ\n\n        unitAttr = OpenMaya.MFnUnitAttribute()\n        nAttr = OpenMaya.MFnNumericAttribute()\n\n        compoundAttribute.x = unitAttr.create(attributeName + \"X\", attributeName + \"X\", unitType, defaultValue.x)\n        unitAttr.setWritable( inputAttr )\n        cls.addAttribute(compoundAttribute.x)\n\n        compoundAttribute.y = unitAttr.create(attributeName + \"Y\", attributeName + \"Y\", unitType, defaultValue.y)\n        unitAttr.setWritable( inputAttr )\n        cls.addAttribute(compoundAttribute.y)\n\n        compoundAttribute.z = unitAttr.create(attributeName + \"Z\", attributeName + \"Z\", unitType, defaultValue.z)\n        unitAttr.setWritable( inputAttr )\n        cls.addAttribute(compoundAttribute.z)\n\n        # Output compound\n        compoundAttribute.compound = nAttr.create(attributeName, attributeName,\n                                     compoundAttribute.x, compoundAttribute.y, compoundAttribute.z)\n        nAttr.setWritable( inputAttr )\n        nAttr.setArray( arrayAttr )\n        nAttr.setUsesArrayDataBuilder( arrayAttr )\n        nAttr.setDisconnectBehavior(OpenMaya.MFnAttribute.kDelete)\n        cls.addAttribute(compoundAttribute.compound)\n\n    @classmethod\n    def addRampAttributes(cls, rampAttributes, attributeName, unitType, defaultAxisValue):\n\n        # Not a compound attribute, just adds them all to the node\n        \n        nAttr = OpenMaya.MFnNumericAttribute()\n\n        rampAttributes.ramp = OpenMaya.MRampAttribute.createCurveRamp(attributeName + \"Ramp\", attributeName + \"Ramp\")\n        cls.addAttribute(rampAttributes.ramp)\n\n        rampAttributes.rampOffset = nAttr.create(attributeName + \"RampOffset\", attributeName + \"RampOffset\", OpenMaya.MFnNumericData.kFloat, 0.0)\n        nAttr.setKeyable( True )\n        cls.addAttribute( rampAttributes.rampOffset )\n\n        rampAttributes.rampAmplitude = nAttr.create(attributeName + \"RampAmplitude\", attributeName + \"RampAmplitude\", OpenMaya.MFnNumericData.kFloat, 0.0)\n        nAttr.setKeyable( True )\n        cls.addAttribute( rampAttributes.rampAmplitude )\n\n        rampAttributes.rampRepeat = nAttr.create(attributeName + \"RampRepeat\", attributeName + \"RampRepeat\", OpenMaya.MFnNumericData.kFloat, 1.0)\n        nAttr.setKeyable( True )\n        cls.addAttribute( rampAttributes.rampRepeat )\n\n        rampAttributes.rampRandomAmplitude = nAttr.create(attributeName + \"RampRandomAmplitude\", attributeName + \"RampRandomAmplitude\", OpenMaya.MFnNumericData.kFloat, 0.0)\n        nAttr.setMin(0.0)\n        nAttr.setSoftMax(1.0)\n        nAttr.setKeyable( True )\n        cls.addAttribute( rampAttributes.rampRandomAmplitude )\n\n        cls.addCompoundVector3Attribute(rampAttributes.rampAxis, attributeName + \"RampAxis\", unitType, False, True, defaultAxisValue)\n\n    @classmethod\n    def addCurveAxisHandleAttribute(cls, curveAxisHandleAttr, attributeName, defaultAxisValue):\n\n        # Schematic view of compound attribute:\n        # curveAxisHandle[]\n        #   curveAxisHandleParameter\n        #   curveAxisHandleAngle\n\n        nAttr = OpenMaya.MFnNumericAttribute()\n        cmpAttr = OpenMaya.MFnCompoundAttribute()\n\n        curveAxisHandleAttr.parameter = nAttr.create(attributeName + \"Parameter\", attributeName + \"Parameter\", OpenMaya.MFnNumericData.kDouble, 0.0)\n        nAttr.setWritable( True )\n        cls.addAttribute(curveAxisHandleAttr.parameter)\n\n        curveAxisHandleAttr.angle = nAttr.create(attributeName + \"Angle\", attributeName + \"Angle\", OpenMaya.MFnNumericData.kDouble, 0.0)\n        nAttr.setWritable( True )\n        cls.addAttribute(curveAxisHandleAttr.angle)\n\n        # cls.addCompoundVector3Attribute(curveAxisHandleAttr.axis, attributeName + \"Axis\", OpenMaya.MFnUnitAttribute.kAngle, False, True, defaultAxisValue)\n\n        # Build compound array attribute\n        curveAxisHandleAttr.compound = cmpAttr.create(attributeName, attributeName)\n        cmpAttr.addChild(curveAxisHandleAttr.parameter)\n        cmpAttr.addChild(curveAxisHandleAttr.angle)\n        cmpAttr.setWritable( True )\n        cmpAttr.setArray( True )\n        cmpAttr.setUsesArrayDataBuilder( True )\n\n        cls.addAttribute(curveAxisHandleAttr.compound)\n\n    @staticmethod\n    def nodeInitializer():\n\n        # Associate the node with its aim manipulator\n        OpenMayaMPx.MPxManipContainer.addToManipConnectTable(kPluginNodeId)\n\n        # To make things more readable\n        node = instanceAlongCurveLocator\n\n        nAttr = OpenMaya.MFnNumericAttribute()\n        matrixAttrFn = OpenMaya.MFnMatrixAttribute()\n        msgAttributeFn = OpenMaya.MFnMessageAttribute()\n        curveAttributeFn = OpenMaya.MFnTypedAttribute()\n        enumFn = OpenMaya.MFnEnumAttribute()\n\n        node.inputTransformAttr = matrixAttrFn.create(\"inputTransformMatrix\", \"inputTransformMatrix\", OpenMaya.MFnMatrixAttribute.kFloat)\n        node.addAttribute( node.inputTransformAttr )\n\n        node.legacyInputTransformAttr = msgAttributeFn.create(\"inputTransform\", \"it\")\n        node.addAttribute( node.legacyInputTransformAttr)\n\n        node.inputShadingGroupAttr = msgAttributeFn.create(\"inputShadingGroup\", \"iSG\")    \n        node.addAttribute( node.inputShadingGroupAttr )\n\n        # Input curve transform\n        node.inputCurveAttr = curveAttributeFn.create( 'inputCurve', 'curve', OpenMaya.MFnData.kNurbsCurve)\n        node.addAttribute( node.inputCurveAttr )\n        \n        # Input instance count    \n        node.instanceCountAttr = nAttr.create(\"instanceCount\", \"iic\", OpenMaya.MFnNumericData.kInt, 5)\n        nAttr.setMin(1)\n        nAttr.setSoftMax(100)\n        nAttr.setChannelBox( False )\n        nAttr.setConnectable( False )\n        node.addAttribute( node.instanceCountAttr)\n\n        node.addCompoundVector3Attribute(node.inputLocalRotationOffsetAttr, \"inputLocalRotationOffset\", OpenMaya.MFnUnitAttribute.kDistance, False, True, OpenMaya.MVector(0.0, 0.0, 0.0))\n        node.addCompoundVector3Attribute(node.inputGlobalRotationOffsetAttr, \"inputGlobalRotationOffset\", OpenMaya.MFnUnitAttribute.kDistance, False, True, OpenMaya.MVector(0.0, 0.0, 0.0))\n\n        node.addCompoundVector3Attribute(node.inputGlobalTranslationOffsetAttr, \"inputGlobalTranslationOffset\", OpenMaya.MFnUnitAttribute.kDistance, False, True, OpenMaya.MVector(0.0, 0.0, 0.0))\n        node.addCompoundVector3Attribute(node.inputLocalTranslationOffsetAttr, \"inputLocalTranslationOffset\", OpenMaya.MFnUnitAttribute.kDistance, False, True, OpenMaya.MVector(0.0, 0.0, 0.0))\n\n        node.addCompoundVector3Attribute(node.inputLocalScaleOffsetAttr, \"inputLocalScaleOffset\", OpenMaya.MFnUnitAttribute.kDistance, False, True, OpenMaya.MVector(1.0, 1.0, 1.0))\n\n        # Curve parameter offset\n        node.distOffsetAttr = nAttr.create(\"distOffset\", \"pOffset\", OpenMaya.MFnNumericData.kFloat, 0.0)\n        nAttr.setMin(0.0)\n        nAttr.setKeyable( True )\n        node.addAttribute( node.distOffsetAttr )\n\n        node.curveStartAttr = nAttr.create(\"curveStart\", \"cStart\", OpenMaya.MFnNumericData.kFloat, 0.0)\n        nAttr.setMin(0.0)\n        nAttr.setSoftMax(1.0)\n        nAttr.setKeyable( True )\n        node.addAttribute( node.curveStartAttr)\n\n        node.curveEndAttr = nAttr.create(\"curveEnd\", \"cEnd\", OpenMaya.MFnNumericData.kFloat, 1.0)\n        nAttr.setMin(0.0)\n        nAttr.setSoftMax(1.0)\n        nAttr.setKeyable( True )\n        node.addAttribute( node.curveEndAttr)\n\n        ## Max instances when defined by instance length\n        node.maxInstancesByLengthAttr = nAttr.create(\"maxInstancesByLength\", \"mibl\", OpenMaya.MFnNumericData.kInt, 50)\n        nAttr.setMin(0)\n        nAttr.setSoftMax(200)\n        nAttr.setChannelBox( False )\n        nAttr.setConnectable( False )\n        node.addAttribute( node.maxInstancesByLengthAttr)\n\n        # Length between instances\n        node.instanceLengthAttr = nAttr.create(\"instanceLength\", \"ilength\", OpenMaya.MFnNumericData.kFloat, 1.0)\n        nAttr.setMin(0.01)\n        nAttr.setSoftMax(1.0)\n        nAttr.setChannelBox( False )\n        nAttr.setConnectable( False )\n        node.addAttribute( node.instanceLengthAttr)\n        \n        # Display override options\n        node.displayTypeAttr = enumFn.create('instanceDisplayType', 'idt')\n        enumFn.addField( \"Normal\", 0 );\n        enumFn.addField( \"Template\", 1 );\n        enumFn.addField( \"Reference\", 2 );\n        enumFn.setDefault(\"Reference\")\n        node.addAttribute( node.displayTypeAttr )\n\n        # Enum for selection of instancing mode\n        node.instancingModeAttr = enumFn.create('instancingMode', 'instancingMode')\n        enumFn.addField( \"Count\", 0 );\n        enumFn.addField( \"Distance\", 1 );\n        node.addAttribute( node.instancingModeAttr )\n\n         # Enum for selection of orientation mode\n        node.orientationModeAttr = enumFn.create('orientationMode', 'orientationMode')\n        enumFn.addField( \"Identity\", 0 );\n        enumFn.addField( \"Copy from Source\", 1 );\n        enumFn.addField( \"Use Curve\", 2 );\n        enumFn.addField( \"Chain\", 3 );\n        enumFn.setDefault(\"Use Curve\")\n        node.addAttribute( node.orientationModeAttr )\n\n        node.inputLocalOrientationAxisAttr = enumFn.create('inputLocalOrientationAxis', 'inputLocalOrientationAxis')\n        enumFn.addField(\"X\", 0)\n        enumFn.addField(\"Y\", 1)\n        enumFn.addField(\"Z\", 2)\n        enumFn.setDefault(\"Z\")\n        node.addAttribute( node.inputLocalOrientationAxisAttr )\n\n        node.bboxAttr = nAttr.create('instanceBoundingBox', 'ibb', OpenMaya.MFnNumericData.kBoolean)\n        node.addAttribute( node.bboxAttr )\n\n        # Default translation ramp axis is UP\n        node.addRampAttributes(node.positionRampAttr, \"position\", OpenMaya.MFnUnitAttribute.kDistance, OpenMaya.MVector(0.0, 1.0, 0.0))\n\n        # Default rotation ramp axis is TANGENT\n        node.addRampAttributes(node.rotationRampAttr, \"rotation\", OpenMaya.MFnUnitAttribute.kDistance, OpenMaya.MVector(0.0, 0.0, 1.0))\n\n        # Default scale axis is uniform\n        node.addRampAttributes(node.scaleRampAttr, \"scale\", OpenMaya.MFnUnitAttribute.kDistance, OpenMaya.MVector(1.0, 1.0, 1.0))\n\n        # Output attributes\n        node.addCompoundVector3Attribute(node.outputTranslationAttr, \"outputTranslation\", OpenMaya.MFnUnitAttribute.kDistance, True, False, OpenMaya.MVector(0.0, 0.0, 0.0))\n        node.addCompoundVector3Attribute(node.outputRotationAttr, \"outputRotation\", OpenMaya.MFnUnitAttribute.kAngle, True, False, OpenMaya.MVector(0.0, 0.0, 0.0))\n        node.addCompoundVector3Attribute(node.outputScaleAttr, \"outputScale\", OpenMaya.MFnUnitAttribute.kDistance, True, False, OpenMaya.MVector(1.0, 1.0, 1.0))\n\n        ## Input instance count    \n        node.enableManipulatorsAttr = nAttr.create(\"enableManipulators\", \"enableManipulators\", OpenMaya.MFnNumericData.kBoolean)\n        node.addAttribute( node.enableManipulatorsAttr)\n\n        node.addCurveAxisHandleAttribute(node.curveAxisHandleAttr, \"curveAxisHandle\", OpenMaya.MVector(0.0,0.0,0.0))\n\n        ## Input handle count\n        node.curveAxisHandleCountAttr = nAttr.create(\"curveAxisHandleCount\", \"curveAxisHandleCount\", OpenMaya.MFnNumericData.kInt, 5)\n        nAttr.setMin(1)\n        nAttr.setSoftMax(100)\n        nAttr.setChannelBox( False )\n        nAttr.setConnectable( False )\n        node.addAttribute( node.curveAxisHandleCountAttr)\n\n        def rampAttributeAffects(rampAttributes, affectedAttr):\n            node.attributeAffects( rampAttributes.ramp, affectedAttr)\n            node.attributeAffects( rampAttributes.rampOffset, affectedAttr)\n            node.attributeAffects( rampAttributes.rampAmplitude, affectedAttr)\n            node.attributeAffects( rampAttributes.rampAxis.compound, affectedAttr)\n            node.attributeAffects( rampAttributes.rampRandomAmplitude, affectedAttr)\n            node.attributeAffects( rampAttributes.rampRepeat, affectedAttr)\n\n        # Curve Axis affects, for manipulator\n        node.attributeAffects( node.inputCurveAttr, node.curveAxisHandleAttr.compound )\n        node.attributeAffects( node.curveAxisHandleCountAttr, node.curveAxisHandleAttr.compound )\n\n        # Translation affects\n        node.attributeAffects( node.inputCurveAttr, node.outputTranslationAttr.compound )\n        node.attributeAffects( node.instanceCountAttr, node.outputTranslationAttr.compound)\n        node.attributeAffects( node.instanceLengthAttr, node.outputTranslationAttr.compound)\n        node.attributeAffects( node.instancingModeAttr, node.outputTranslationAttr.compound)\n        node.attributeAffects( node.maxInstancesByLengthAttr, node.outputTranslationAttr.compound)\n        node.attributeAffects( node.distOffsetAttr, node.outputTranslationAttr.compound )\n        node.attributeAffects( node.inputTransformAttr, node.outputTranslationAttr.compound )\n\n        node.attributeAffects( node.inputLocalOrientationAxisAttr, node.outputTranslationAttr.compound)\n\n        node.attributeAffects(node.inputLocalTranslationOffsetAttr.compound, node.outputTranslationAttr.compound )\n        node.attributeAffects(node.inputGlobalTranslationOffsetAttr.compound, node.outputTranslationAttr.compound )\n\n        node.attributeAffects( node.enableManipulatorsAttr, node.outputTranslationAttr.compound)\n        node.attributeAffects( node.curveAxisHandleAttr.compound, node.outputTranslationAttr.compound)\n\n        node.attributeAffects( node.curveStartAttr, node.outputTranslationAttr.compound )\n        node.attributeAffects( node.curveEndAttr, node.outputTranslationAttr.compound )\n\n        rampAttributeAffects(node.positionRampAttr, node.outputTranslationAttr.compound)\n\n        # Rotation affects\n        node.attributeAffects( node.inputCurveAttr, node.outputRotationAttr.compound )\n        node.attributeAffects( node.instanceCountAttr, node.outputRotationAttr.compound)\n        node.attributeAffects( node.instanceLengthAttr, node.outputRotationAttr.compound)\n        node.attributeAffects( node.instancingModeAttr, node.outputRotationAttr.compound)\n        node.attributeAffects( node.maxInstancesByLengthAttr, node.outputRotationAttr.compound)\n        node.attributeAffects( node.orientationModeAttr, node.outputRotationAttr.compound)\n        node.attributeAffects( node.distOffsetAttr, node.outputRotationAttr.compound )\n        node.attributeAffects( node.inputTransformAttr, node.outputRotationAttr.compound )\n\n        node.attributeAffects( node.inputLocalOrientationAxisAttr, node.outputRotationAttr.compound)\n        \n        node.attributeAffects( node.enableManipulatorsAttr, node.outputRotationAttr.compound)\n        node.attributeAffects( node.curveAxisHandleAttr.compound, node.outputRotationAttr.compound)\n\n        node.attributeAffects( node.inputGlobalRotationOffsetAttr.compound, node.outputRotationAttr.compound)\n        node.attributeAffects( node.inputLocalRotationOffsetAttr.compound, node.outputRotationAttr.compound)        \n\n        rampAttributeAffects(node.rotationRampAttr, node.outputRotationAttr.compound)\n\n        node.attributeAffects( node.curveStartAttr, node.outputRotationAttr.compound )\n        node.attributeAffects( node.curveEndAttr, node.outputRotationAttr.compound )\n\n        # Scale affects\n        node.attributeAffects( node.inputCurveAttr, node.outputScaleAttr.compound )\n        node.attributeAffects( node.instanceCountAttr, node.outputScaleAttr.compound)\n        node.attributeAffects( node.instanceLengthAttr, node.outputScaleAttr.compound)\n        node.attributeAffects( node.instancingModeAttr, node.outputScaleAttr.compound)\n        node.attributeAffects( node.maxInstancesByLengthAttr, node.outputScaleAttr.compound)\n        node.attributeAffects( node.distOffsetAttr, node.outputScaleAttr.compound )\n        node.attributeAffects( node.inputTransformAttr, node.outputScaleAttr.compound )\n\n        node.attributeAffects( node.inputLocalOrientationAxisAttr, node.outputScaleAttr.compound)\n        \n        node.attributeAffects( node.enableManipulatorsAttr, node.outputScaleAttr.compound)\n        node.attributeAffects( node.curveAxisHandleAttr.compound, node.outputScaleAttr.compound)\n\n        rampAttributeAffects(node.scaleRampAttr, node.outputScaleAttr.compound)\n\n        node.attributeAffects( node.curveStartAttr, node.outputScaleAttr.compound )\n        node.attributeAffects( node.curveEndAttr, node.outputScaleAttr.compound )\n\n        node.attributeAffects(node.inputLocalScaleOffsetAttr.compound, node.outputScaleAttr.compound )\n\n###############\n# AE TEMPLATE #\n###############\ndef loadAETemplateCallback(nodeName):\n    AEinstanceAlongCurveLocatorTemplate(nodeName)\n\nclass AEinstanceAlongCurveLocatorTemplate(pm.ui.AETemplate):\n\n    def addControl(self, control, label=None, **kwargs):\n        pm.ui.AETemplate.addControl(self, control, label=label, **kwargs)\n\n    def beginLayout(self, name, collapse=True):\n        pm.ui.AETemplate.beginLayout(self, name, collapse=collapse)\n\n    def __init__(self, nodeName):\n        pm.ui.AETemplate.__init__(self,nodeName)\n        self.thisNode = None\n        self.node = pm.PyNode(self.nodeName)\n\n        if self.node.type() == kPluginNodeName:\n\n            # Suppress all attributes, so that no extra controls are shown\n            for attr in pm.listAttr(nodeName):\n                self.suppress(attr)\n\n            self.callCustom(lambda: self.showTitle(), lambda: None)\n\n            self.beginScrollLayout()\n\n            self.beginLayout(\"General\", collapse=0)\n\n            # Base controls\n            annotation = \"Defines if the amount of instances is defined manually or by a predefined distance.\"\n            self.addControl(\"instancingMode\", label=\"Instancing Mode\", changeCommand=self.onInstanceModeChanged, annotation=annotation)\n\n            annotation = \"The amount of instances to distribute. These are distributed uniformly.\"\n            self.addControl(\"instanceCount\", label=\"Count\", changeCommand=self.onInstanceModeChanged, annotation=annotation)\n\n            annotation = \"If the locator mode is on Distance, this length will define the spacing between each instance. <br> <br> Note that if the curve length is greater than an integer amount of distances, some space will be left unoccupied.\"\n            self.addControl(\"instanceLength\", label=\"Distance\", changeCommand=self.onInstanceModeChanged, annotation=annotation)\n\n            annotation = \"A safe guard to prevent having too many instances.\"\n            self.addControl(\"maxInstancesByLength\", label=\"Max Instances\", changeCommand=self.onInstanceModeChanged, annotation=annotation)\n\n            self.addSeparator()\n\n            annotation = \"An offset for the evaluation of the curve position/rotation. This also modifies the ramp evaluation. \"\n            self.addControl(\"distOffset\", label=\"Curve Offset\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"distOffset\"), annotation=annotation)\n\n            annotation = \"A cutoff value for the curve start point. This is normalized, so it should be in [0,1), but can have greater values for looping\"\n            self.addControl(\"curveStart\", label=\"Curve Start\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"curveStart\"), annotation=annotation)\n\n            annotation = \"A cutoff value for the curve end point. This is normalized, so it should be in (0,1], but can have greater values for looping\"\n            self.addControl(\"curveEnd\", label=\"Curve End\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"curveEnd\"), annotation=annotation)\n\n            self.addSeparator()\n\n            # Orientation controls\n            annotation = \"Identity: objects have no rotation. <br> <br> Copy From Source: Each object will copy the rotation transformation from the original. <br> <br> Use Curve: Objects will be aligned by the curve tangent with respect to the selected axis. <br> <br> Chain: Same as Use Curve, but with an additional 90 degree twist for odd instances.\"\n            self.addControl(\"orientationMode\", label=\"Orientation Mode\", changeCommand=lambda nodeName: self.updateOrientationChange(nodeName), annotation=annotation)\n\n            annotation = \"Each instance will be rotated so that this axis is parallel to the curve tangent.\"\n            self.addControl(\"inputLocalOrientationAxis\", label=\"Local Axis\" , changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputLocalOrientationAxis\"), annotation=annotation)\n\n            self.addSeparator()\n\n            # Manipulator controls\n            annotation = \"When enabled, the rotations can be manually defined.\"\n            self.addControl(\"enableManipulators\", label=\"Enable manipulators\", changeCommand=lambda nodeName: self.updateManipCountDimming(nodeName), annotation=annotation)\n\n            annotation = \"This number will define the number of handles to manipulate the curve orientation. For changes to take effect, you must click the Edit Manipulators button. <br> <br> When incrementing the number, new handles will be created in between existing ones, interpolating their values.\"\n            self.addControl(\"curveAxisHandleCount\", label=\"Manipulator count\", changeCommand=lambda nodeName: self.updateManipCountDimming(nodeName), annotation=annotation)\n            self.callCustom(lambda attr: self.buttonNew(nodeName), self.buttonUpdate, \"curveAxisHandleCount\")\n\n            self.addSeparator()\n\n            # Instance look controls\n            annotation = \"By default, objects display type is on Reference, so they cannot be selected. To change this, select Normal.\"\n            self.addControl(\"instanceDisplayType\", label=\"Instance Display Type\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"instanceDisplayType\"), annotation=annotation)\n\n            annotation = \"When true, objects will be shown as bounding boxes only.\"\n            self.addControl(\"instanceBoundingBox\", label=\"Use bounding box\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"instanceBoundingBox\"), annotation=annotation)\n            \n            self.addSeparator()\n\n            self.endLayout()\n            \n            def showRampControls(rampName):\n\n                self.beginLayout(rampName.capitalize() + \" Control\", collapse=True)\n                mel.eval('AEaddRampControl(\"' + nodeName + \".\" + rampName + 'Ramp\"); ')\n\n                annotation = \"An offset when evaluating the ramp. This is similar to the curve offset, but works only for the ramp.\"\n                self.addControl(rampName + \"RampOffset\", label= rampName.capitalize() + \" Ramp Offset\", annotation=annotation)\n\n                annotation = \"A multiplier to evaluate multiple times the same ramp over the curve\"\n                self.addControl(rampName + \"RampRepeat\", label= rampName.capitalize() + \" Ramp Repeat\", annotation=annotation)\n\n                annotation = \"Ramp values are multiplied by this amplitude.\"\n                self.addControl(rampName + \"RampAmplitude\", label= rampName.capitalize() + \" Ramp Amplitude\", annotation=annotation)\n\n                annotation = \"A random value for the ramp amplitude. The result is <br><br> amplitude + (random() * 2.0 - 1.0) * <b>randomAmplitude</b>\"\n                self.addControl(rampName + \"RampRandomAmplitude\", label= rampName.capitalize() + \" Ramp Random\", annotation=annotation)\n\n                annotation = \"The axis over which the ramp is evaluated. The result depends on the type of ramp. <br> <br> The (X,Y,Z) values are over the local space of the transformed object (right/bitangent, up/normal, forward/tangent).\"\n                self.addControl(rampName + \"RampAxis\", label= rampName.capitalize() + \" Ramp Axis\", annotation=annotation)\n\n                self.endLayout()\n\n            self.beginLayout(\"Offsets\", collapse=True)\n\n            annotation = \"A translation offset over the curve local space.\"\n            self.addControl(\"inputLocalTranslationOffset\", label=\"Local Translation Offset\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputLocalTranslationOffset\"), annotation=annotation)\n\n            annotation = \"A translation offset in worldspace XYZ.\"\n            self.addControl(\"inputGlobalTranslationOffset\", label=\"Global Translation Offset\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputGlobalTranslationOffset\"), annotation=annotation)\n\n            self.addSeparator()\n\n            annotation = \"A rotation offset over the curve local space. This offset is initialized to the original object rotation. \"\n            self.addControl(\"inputLocalRotationOffset\", label=\"Local Rotation Offset\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputLocalRotationOffset\"), annotation=annotation)\n\n            annotation = \"A worldspace rotation offset.\"\n            self.addControl(\"inputGlobalRotationOffset\", label=\"Global Rotation Offset\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputGlobalRotationOffset\"), annotation=annotation)\n\n            self.addSeparator()\n\n            annotation = \"A scale offset over the object local space. This offset is initialized to the original object scale.\"\n            self.addControl(\"inputLocalScaleOffset\", label=\"Local Scale Offset\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputLocalScaleOffset\"), annotation=annotation)\n            \n            self.endLayout()\n\n            showRampControls(\"position\")\n            showRampControls(\"rotation\")\n            showRampControls(\"scale\")\n\n            self.beginLayout(\"Extra\", collapse=True)\n\n            # Additional info\n            annotation = \"The input object transform. DO NOT REMOVE THIS CONNECTION, or the node will stop working correctly.\"\n            self.addControl(\"inputTransformMatrix\", label=\"Input object\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputTransformMatrix\"), annotation=annotation)\n\n            annotation = \"The shading group for the instances. When instantiating, they will be assigned this SG.\"\n            self.addControl(\"inputShadingGroup\", label=\"Shading Group\", changeCommand=lambda nodeName: self.updateDimming(nodeName, \"inputShadingGroup\"), annotation=annotation)\n\n            self.endLayout()\n\n            self.endScrollLayout()\n\n    def showTitle(self):\n        pm.text(\"Instance Along Curve v\" + kPluginVersion, font=\"boldLabelFont\")\n\n    def buttonNew(self, nodeName):\n\n        # pm.separator( height=5, style='none')\n        pm.rowLayout(numberOfColumns=3, adjustableColumn=1, columnWidth3=(80, 100, 100))\n\n        self.updateManipButton = pm.button( label='Edit Manipulators...', command=lambda *args: self.onEditManipulators(nodeName))\n        self.updateManipButton.setAnnotation(\"When pressed, the manipulators will be selected. If the manipulator count changed, it will be updated.\")\n\n        self.resetPositionsButton = pm.button( label='Reset Positions', command=lambda *args: self.onResetManipPositions(nodeName))\n        self.resetPositionsButton.setAnnotation(\"When pressed, the manipulators will be uniformly distributed over the curve.\")\n\n        self.resetAnglesButton = pm.button( label='Reset Angles', command=lambda *args: self.onResetManipAngles(nodeName))\n        self.resetAnglesButton.setAnnotation(\"When pressed, all the manipulator angles will be reset to 0.\")\n    \n    def buttonUpdate(self, attr):\n\n        nodeName = pm.PyNode(attr).nodeName()\n        self.updateManipButton.setCommand(lambda *args: self.onEditManipulators(nodeName))\n        self.resetPositionsButton.setCommand(lambda *args: self.onResetManipPositions(nodeName))\n        self.resetAnglesButton.setCommand(lambda *args: self.onResetManipAngles(nodeName))\n    \n    def onResetManipPositions(self, nodeName):\n\n        # First, show manips to update manip count\n        self.onEditManipulators(nodeName)\n        res = pm.confirmDialog( title='Confirm reset positions', message='Are you sure you want to reset the manipulators positions?', button=['Yes','No'], defaultButton='Yes', cancelButton='No', dismissString='No' )\n\n        if res == \"Yes\":\n\n            pm.select( clear=True )\n\n            node = pm.PyNode(nodeName)\n            curve = node.inputCurve\n            handles = node.curveAxisHandle\n\n            if len(curve.connections()) == 1:\n\n                curveNode = curve.connections()[0]\n                maxParam = curveNode.findParamFromLength(curveNode.length())\n\n                count = min(node.curveAxisHandleCount.get(), handles.numElements())\n\n                index = 0\n                for h in handles:\n                    if index < count:\n                        h.children()[0].set(index * maxParam / float(count))\n                        index = index + 1\n                        \n                pm.select(nodeName)\n                pm.runtime.ShowManipulators()\n\n    def onResetManipAngles(self, nodeName):\n        \n        # First, show manips to update manip count\n        self.onEditManipulators(nodeName)\n        res = pm.confirmDialog( title='Confirm reset angles', message='Are you sure you want to reset the manipulators angles?', button=['Yes','No'], defaultButton='Yes', cancelButton='No', dismissString='No' )\n\n        if res == \"Yes\":\n\n            pm.select( clear=True )\n\n            node = pm.PyNode(nodeName)\n            handles = node.curveAxisHandle\n            count = min(node.curveAxisHandleCount.get(), handles.numElements())\n\n            index = 0\n            for h in handles:\n                if index < count:\n                    h.children()[1].set(0.0)\n                    index = index + 1\n\n            pm.select(nodeName)\n            pm.runtime.ShowManipulators()\n\n    def onEditManipulators(self, nodeName):\n        \n        # Unselect first, to trigger rebuilding of manips\n        pm.select( clear=True )\n        pm.select(nodeName)\n\n        pm.runtime.ShowManipulators()\n\n    # When orientation changes, update related controls...  \n    def updateOrientationChange(self, nodeName):\n        self.updateDimming(nodeName, \"orientationMode\")\n        self.updateManipCountDimming(nodeName)\n\n    def onRampUpdate(self, attr):\n        pm.gradientControl(attr)\n\n    def updateManipCountDimming(self, nodeName):\n\n        enableManips = pm.PyNode(nodeName).enableManipulators.get()\n\n        self.updateManipButton.setEnable(enableManips)\n        self.resetAnglesButton.setEnable(enableManips)\n        self.resetPositionsButton.setEnable(enableManips)        \n        self.updateDimming(nodeName, \"curveAxisHandleCount\", enableManips)\n\n    def updateDimming(self, nodeName, attr, additionalCondition = True):\n\n        if pm.PyNode(nodeName).type() == kPluginNodeName:\n\n            node = pm.PyNode(nodeName)\n            instanced = node.isInstanced()\n            hasInputTransform = node.inputTransform.isConnected() or node.inputTransformMatrix.isConnected()\n            hasInputCurve = node.inputCurve.isConnected()\n\n            self.dimControl(nodeName, attr, instanced or (not hasInputCurve) or (not hasInputTransform) or (not additionalCondition))\n\n    def onInstanceModeChanged(self, nodeName):\n        self.updateDimming(nodeName, \"instancingMode\")\n\n        if pm.PyNode(nodeName).type() == kPluginNodeName:\n\n            nodeAttr = pm.PyNode(nodeName + \".instancingMode\")\n            mode = nodeAttr.get(\"instancingMode\")\n\n            # If dimmed, do not update dimming\n            if mode == 0:\n                self.dimControl(nodeName, \"instanceLength\", True)\n                self.dimControl(nodeName, \"maxInstancesByLength\", True)\n\n                self.updateDimming(nodeName, \"instanceCount\")\n            else:\n                self.updateDimming(nodeName, \"instanceLength\")\n                self.updateDimming(nodeName, \"maxInstancesByLength\")\n                \n                self.dimControl(nodeName, \"instanceCount\", True)\n\n# Command\nclass instanceAlongCurveCommand(OpenMayaMPx.MPxCommand):\n\n    def __init__(self):\n        OpenMayaMPx.MPxCommand.__init__(self)\n        self.mUndo = []\n\n    def isUndoable(self):\n        return True\n\n    def undoIt(self): \n        OpenMaya.MGlobal.displayInfo( \"Undo: instanceAlongCurveCommand\\n\" )\n\n        # Reversed for undo :)\n        for m in reversed(self.mUndo):\n            m.undoIt()\n\n    def redoIt(self): \n        OpenMaya.MGlobal.displayInfo( \"Redo: instanceAlongCurveCommand\\n\" )\n        \n        for m in self.mUndo:\n            m.doIt()\n\n    def hasShapeBelow(self, dagPath):\n\n        sutil = OpenMaya.MScriptUtil()\n        uintptr = sutil.asUintPtr()\n        sutil.setUint(uintptr , 0)\n\n        dagPath.numberOfShapesDirectlyBelow(uintptr)\n\n        return sutil.getUint(uintptr) > 0\n\n    def findShadingGroup(self, dagPath):\n\n        # Search in children first before extending to shape\n        for child in xrange(dagPath.childCount()):\n            childDagPath = OpenMaya.MDagPath()\n            fnDagNode = OpenMaya.MFnDagNode(dagPath.child(child))\n            fnDagNode.getPath(childDagPath)\n\n            fnSet = self.findShadingGroup(childDagPath)\n\n            if fnSet is not None:\n                return fnSet\n\n        if self.hasShapeBelow(dagPath):\n            dagPath.extendToShape()\n            fnDepNode = OpenMaya.MFnDependencyNode(dagPath.node())\n\n            instPlugArray = fnDepNode.findPlug(\"instObjGroups\")\n            instPlugArrayElem = instPlugArray.elementByLogicalIndex(dagPath.instanceNumber())\n\n            if instPlugArrayElem.isConnected():\n                connectedPlugs = OpenMaya.MPlugArray()      \n                instPlugArrayElem.connectedTo(connectedPlugs, False, True)\n\n                if connectedPlugs.length() == 1:\n                    sgNode = connectedPlugs[0].node()\n\n                    if sgNode.hasFn(OpenMaya.MFn.kSet):\n                        return OpenMaya.MFnSet(sgNode)\n\n        return None\n        \n    def doIt(self,argList):\n        \n        try:\n            list = OpenMaya.MSelectionList()\n            OpenMaya.MGlobal.getActiveSelectionList(list)\n\n            if list.length() == 2:\n                curveDagPath = OpenMaya.MDagPath()\n                list.getDagPath(0, curveDagPath)\n                curveDagPath.extendToShape()\n\n                shapeDagPath = OpenMaya.MDagPath()\n                list.getDagPath(1, shapeDagPath)           \n\n                if(curveDagPath.node().hasFn(OpenMaya.MFn.kNurbsCurve)):\n\n                    # We need the curve transform\n                    curvePlug = OpenMaya.MFnDagNode(curveDagPath).findPlug(\"worldSpace\", False).elementByLogicalIndex(0)\n\n                    # We need the shape's transform too\n                    transformFn = OpenMaya.MFnDagNode(shapeDagPath.transform())\n                    transformMessagePlug = transformFn.findPlug(\"worldMatrix\", True)\n                    transformMessagePlug = transformMessagePlug.elementByLogicalIndex(0)\n\n                    shadingGroupFn = self.findShadingGroup(shapeDagPath)\n\n                    # Create node first\n                    mdagModifier = OpenMaya.MDagModifier()\n                    self.mUndo.append(mdagModifier)\n                    newNode = mdagModifier.createNode(kPluginNodeId)\n                    mdagModifier.doIt()\n\n                    # Assign new correct name and select new locator\n                    newNodeFn = OpenMaya.MFnDagNode(newNode)\n                    newNodeFn.setName(\"instanceAlongCurveLocator#\")\n                    newNodeTransformName = newNodeFn.name()\n\n                    # Get the node shape\n                    nodeShapeDagPath = OpenMaya.MDagPath()\n                    newNodeFn.getPath(nodeShapeDagPath)\n                    nodeShapeDagPath.extendToShape()\n                    newNodeFn = OpenMaya.MFnDagNode(nodeShapeDagPath)\n\n                    def setupRamp(rampAttr):\n\n                        # Set default ramp values\n                        defaultPositions = OpenMaya.MFloatArray(1, 0.0)\n                        defaultValues = OpenMaya.MFloatArray(1, 1.0)\n                        defaultInterpolations = OpenMaya.MIntArray(1, 3)\n\n                        plug = newNodeFn.findPlug(rampAttr.ramp)\n                        ramp = OpenMaya.MRampAttribute(plug)\n                        ramp.addEntries(defaultPositions, defaultValues, defaultInterpolations)\n\n                    setupRamp(instanceAlongCurveLocator.positionRampAttr)\n                    setupRamp(instanceAlongCurveLocator.rotationRampAttr)\n                    setupRamp(instanceAlongCurveLocator.scaleRampAttr)\n\n                    # Select new node shape\n                    OpenMaya.MGlobal.clearSelectionList()\n                    msel = OpenMaya.MSelectionList()\n                    msel.add(nodeShapeDagPath)\n                    OpenMaya.MGlobal.setActiveSelectionList(msel)\n\n                    # Connect :D\n                    mdagModifier = OpenMaya.MDagModifier()\n                    self.mUndo.append(mdagModifier)               \n                    mdagModifier.connect(curvePlug, newNodeFn.findPlug(instanceAlongCurveLocator.inputCurveAttr))\n                    mdagModifier.connect(transformMessagePlug, newNodeFn.findPlug(instanceAlongCurveLocator.inputTransformAttr))\n\n                    if shadingGroupFn is not None:\n                        shadingGroupMessagePlug = shadingGroupFn.findPlug(\"message\", True)\n                        mdagModifier.connect(shadingGroupMessagePlug, newNodeFn.findPlug(instanceAlongCurveLocator.inputShadingGroupAttr))\n\n                    mdagModifier.doIt()\n\n                    # (pymel) create a locator and make it the parent\n                    locator = pm.createNode('locator', ss=True, p=newNodeTransformName)\n\n                    # Show AE\n                    mel.eval(\"openAEWindow\")\n\n                    instanceCountPlug = newNodeFn.findPlug(\"instanceCount\", False)\n                    instanceCountPlug.setInt(10)\n\n                    # Rotation offset initialized to original rotation\n                    rotX = transformFn.findPlug(\"rotateX\", False).asMAngle().asDegrees()\n                    rotY = transformFn.findPlug(\"rotateY\", False).asMAngle().asDegrees()\n                    rotZ = transformFn.findPlug(\"rotateZ\", False).asMAngle().asDegrees()\n\n                    plugOffsetX = newNodeFn.findPlug(\"inputLocalRotationOffsetX\", False)\n                    plugOffsetY = newNodeFn.findPlug(\"inputLocalRotationOffsetY\", False)\n                    plugOffsetZ = newNodeFn.findPlug(\"inputLocalRotationOffsetZ\", False)\n\n                    plugOffsetX.setDouble(rotX)\n                    plugOffsetY.setDouble(rotY)\n                    plugOffsetZ.setDouble(rotZ)\n\n                    # Scale offset initialized to original scale\n                    scaleX = transformFn.findPlug(\"scaleX\", False).asFloat()\n                    scaleY = transformFn.findPlug(\"scaleY\", False).asFloat()\n                    scaleZ = transformFn.findPlug(\"scaleZ\", False).asFloat()\n\n                    plugOffsetX = newNodeFn.findPlug(\"inputLocalScaleOffsetX\", False)\n                    plugOffsetY = newNodeFn.findPlug(\"inputLocalScaleOffsetY\", False)\n                    plugOffsetZ = newNodeFn.findPlug(\"inputLocalScaleOffsetZ\", False)\n\n                    plugOffsetX.setDouble(scaleX)\n                    plugOffsetY.setDouble(scaleY)\n                    plugOffsetZ.setDouble(scaleZ)\n                    \n                else:\n                    sys.stderr.write(\"Please select a curve first\")\n            else:\n                sys.stderr.write(\"Please select a curve and a shape\")\n        except:\n            sys.stderr.write('Failed trying to create locator. stack trace: \\n')\n            sys.stderr.write(traceback.format_exc())\n\n    @staticmethod\n    def cmdCreator():\n        return OpenMayaMPx.asMPxPtr( instanceAlongCurveCommand() )\n\nclass instanceAlongCurveLocatorManip(OpenMayaMPx.MPxManipContainer):\n\n    def __init__(self):\n        OpenMayaMPx.MPxManipContainer.__init__(self)\n        self.nodeFn = OpenMaya.MFnDependencyNode()\n\n    @staticmethod\n    def nodeCreator():\n        return OpenMayaMPx.asMPxPtr( instanceAlongCurveLocatorManip() )\n\n    @staticmethod\n    def nodeInitializer():\n        OpenMayaMPx.MPxManipContainer.initialize()\n\n    def createChildren(self):\n\n        # List of tuples\n        self.manipCount = 0\n        self.manipHandleList = []\n        self.manipIndexCallbacks = {}\n\n        selectedObjects = OpenMaya.MSelectionList()\n        OpenMaya.MGlobal.getActiveSelectionList(selectedObjects)\n\n        # Because we need to know the selected object to manipulate, we cannot manipulate various nodes at once...\n        if selectedObjects.length() != 1:\n            return None\n\n        dagPath = OpenMaya.MDagPath()\n        selectedObjects.getDagPath(0, dagPath)\n        dagPath.extendToShape()\n\n        nodeFn = OpenMaya.MFnDependencyNode(dagPath.node())\n        enableManipulators = nodeFn.findPlug(instanceAlongCurveLocator.enableManipulatorsAttr).asBool()\n\n        # If the node is not using the custom rotation, prevent the user from breaking it ;)\n        if not enableManipulators:\n            return None\n\n        self.manipCount = nodeFn.findPlug(instanceAlongCurveLocator.curveAxisHandleCountAttr).asInt()\n\n        for i in xrange(self.manipCount):\n            pointOnCurveManip = self.addPointOnCurveManip(\"pointCurveManip\" + str(i), \"pointCurve\" + str(i))\n            discManip = self.addDiscManip(\"discManip\" + str(i), \"disc\" + str(i))\n            self.manipHandleList.append((pointOnCurveManip, discManip))\n\n    def getSortedCurveAxisArrayFromPlug(self, nodeFn, count):\n\n        axisHandles = []\n        plugArray = nodeFn.findPlug(instanceAlongCurveLocator.curveAxisHandleAttr.compound)\n\n        for i in xrange(count):\n            plug = plugArray.elementByLogicalIndex(i)\n            parameterPlug = plug.child(instanceAlongCurveLocator.curveAxisHandleAttr.parameter)\n            anglePlug = plug.child(instanceAlongCurveLocator.curveAxisHandleAttr.angle)\n\n            axisHandles.append((i, parameterPlug.asDouble(), anglePlug.asDouble()))\n\n        def getKey(item):\n            return item[1]\n\n        return sorted(axisHandles, key=getKey)\n\n    def connectToDependNode(self, node):\n\n        try:\n            self.nodeFn = OpenMaya.MFnDependencyNode(node)\n            curvePlug = self.nodeFn.findPlug(instanceAlongCurveLocator.inputCurveAttr)        \n            curveAxisHandleArrayPlug = self.nodeFn.findPlug(instanceAlongCurveLocator.curveAxisHandleAttr.compound)\n\n            self.curveFn = OpenMaya.MFnNurbsCurve(getFnFromPlug(curvePlug, OpenMaya.MFn.kNurbsCurve))\n            maxParam = self.curveFn.findParamFromLength(self.curveFn.length())\n\n            if self.manipCount == 0:\n                return None\n\n            handleCountPlug = self.nodeFn.findPlug(instanceAlongCurveLocator.curveAxisHandleCountAttr)\n            expectedHandleCount = handleCountPlug.asInt()\n            actualHandleCount = curveAxisHandleArrayPlug.numElements()\n            axisHandlesSorted = self.getSortedCurveAxisArrayFromPlug(self.nodeFn, actualHandleCount)\n\n            # Amount of new handles\n            handlesToInit = self.manipCount - actualHandleCount\n            handlesPerSegment = 0\n\n            if actualHandleCount > 0:\n                handlesPerSegment = max(math.ceil(handlesToInit / float(actualHandleCount)), 1)\n\n            # Build and connect all plugs\n            # Note: Previous plugs are still with remnant values (newHandleCount < oldHandleCount),\n            # but because when interpolating we just read the handle count attr, it works.\n            for i in xrange(self.manipCount):\n\n                # Handle data\n                curveAxisHandlePlug = curveAxisHandleArrayPlug.elementByLogicalIndex(i)\n                curveParameterPlug = curveAxisHandlePlug.child(instanceAlongCurveLocator.curveAxisHandleAttr.parameter)\n                curveAnglePlug = curveAxisHandlePlug.child(instanceAlongCurveLocator.curveAxisHandleAttr.angle)\n\n                fnCurvePoint = OpenMayaUI.MFnPointOnCurveManip(self.manipHandleList[i][0])\n                fnCurvePoint.connectToCurvePlug(curvePlug)\n                fnCurvePoint.connectToParamPlug(curveParameterPlug)\n                \n                # If we are adding a new handle, we should initialize this handle to some reasonable param/rotation\n                # Otherwise, just keep the previous handle data... it seems the most usable solution\n                if i >= actualHandleCount:\n\n                    if actualHandleCount > 1:\n\n                        # We distribute these new handles over existing segments, so try to distribute them evenly\n                        handleSegmentIndex = (i - actualHandleCount) % actualHandleCount\n                        handleEndSegmendIndex = (handleSegmentIndex + 1) % actualHandleCount\n                        handleSegmentSubIndex = (i - actualHandleCount) / actualHandleCount\n\n                        pT = float(handleSegmentSubIndex + 1) / float(handlesPerSegment + 1)\n                        pFrom = axisHandlesSorted[handleSegmentIndex][1]\n                        pTo = axisHandlesSorted[handleEndSegmendIndex][1]\n\n                        angleFrom = axisHandlesSorted[handleSegmentIndex][2]\n                        angleTo = axisHandlesSorted[handleEndSegmendIndex][2]\n\n                        # Wrap around in last segment\n                        if handleSegmentIndex + 1 >= actualHandleCount:\n                            pTo += maxParam\n                        \n                        # Interpolate both parameters and angle...\n                        lerpP = pFrom + (pTo - pFrom) * pT\n                        lerpAngle = angleFrom + (angleTo - angleFrom)  * pT\n\n                        curveParameterPlug.setFloat(lerpP)\n                        curveAnglePlug.setDouble(lerpAngle)\n\n                    else:\n                        # Default case... just add them over the curve\n                        curveParameterPlug.setFloat(self.curveFn.findParamFromLength(self.curveFn.length() * float(i) / float(self.manipCount)))\n\n                fnDisc = OpenMayaUI.MFnDiscManip(self.manipHandleList[i][1])\n                fnDisc.connectToAnglePlug(curveAnglePlug)\n                discCenterIndex = fnDisc.centerIndex()\n                discAxisIndex = fnDisc.axisIndex()\n\n                self.addPlugToManipConversion(discCenterIndex)\n                self.addPlugToManipConversion(discAxisIndex)\n\n                self.manipIndexCallbacks[discCenterIndex] = (self.discCenterConversion, i) # Store index value\n                self.manipIndexCallbacks[discAxisIndex] = (self.discAxisConversion, i) # Store index value\n\n            self.finishAddingManips()        \n            OpenMayaMPx.MPxManipContainer.connectToDependNode(self, node)\n\n        except:    \n            sys.stderr.write('Failed trying to connect manipulators. Stack trace: \\n')\n            sys.stderr.write(traceback.format_exc())\n\n    def discAxisConversion(self, manipTuple):\n\n        fnCurvePoint = OpenMayaUI.MFnPointOnCurveManip(manipTuple[0])        \n        param = fnCurvePoint.parameter()\n\n        tangent = self.curveFn.tangent(param, OpenMaya.MSpace.kWorld)\n\n        numData = OpenMaya.MFnNumericData()\n        numDataObj = numData.create(OpenMaya.MFnNumericData.k3Double)\n        numData.setData3Double(tangent.x, tangent.y, tangent.z)\n        manipData = OpenMayaUI.MManipData(numDataObj)\n        return manipData\n\n    def discCenterConversion(self, manipTuple):\n\n        fnCurvePoint = OpenMayaUI.MFnPointOnCurveManip(manipTuple[0])\n        center = fnCurvePoint.curvePoint()\n\n        numData = OpenMaya.MFnNumericData()\n        numDataObj = numData.create(OpenMaya.MFnNumericData.k3Double)\n        numData.setData3Double(center.x, center.y, center.z)\n        manipData = OpenMayaUI.MManipData(numDataObj)\n        return manipData\n\n    def plugToManipConversion(self, manipIndex):\n\n        if manipIndex in self.manipIndexCallbacks:\n            curveHandleIndex = self.manipIndexCallbacks[manipIndex][1]\n            return self.manipIndexCallbacks[manipIndex][0](self.manipHandleList[curveHandleIndex])\n\n        print \"Manip callback not set; returning invalid data!\"\n\n        numData = OpenMaya.MFnNumericData()\n        numDataObj = numData.create(OpenMaya.MFnNumericData.k3Double)\n        numData.setData3Double(0.0, 0.0, 0.0)\n        manipData = OpenMayaUI.MManipData(numDataObj)\n        return manipData\n\ndef initializePlugin( mobject ):\n    mplugin = OpenMayaMPx.MFnPlugin( mobject, \"mmerchante\", kPluginVersion )\n    try:\n        if (OpenMaya.MGlobal.mayaState() != OpenMaya.MGlobal.kBatch) and (OpenMaya.MGlobal.mayaState() != OpenMaya.MGlobal.kLibraryApp):\n            \n            # Register command\n            mplugin.registerCommand( kPluginCmdName, instanceAlongCurveCommand.cmdCreator )\n\n            mplugin.addMenuItem(\"Instance Along Curve\", \"MayaWindow|mainEditMenu\", kPluginCmdName, \"\")\n\n            # Register AE template\n            pm.callbacks(addCallback=loadAETemplateCallback, hook='AETemplateCustomContent', owner=kPluginNodeName)\n\n            # Register IAC manip node\n            mplugin.registerNode( kPluginManipNodeName, kPluginNodeManipId, instanceAlongCurveLocatorManip.nodeCreator, instanceAlongCurveLocatorManip.nodeInitializer, OpenMayaMPx.MPxNode.kManipContainer )\n\n        # Register IAC node\n        mplugin.registerNode( kPluginNodeName, kPluginNodeId, instanceAlongCurveLocator.nodeCreator,\n                              instanceAlongCurveLocator.nodeInitializer, OpenMayaMPx.MPxNode.kLocatorNode, kPluginNodeClassify )\n\n    except:\n        sys.stderr.write('Failed to register plugin instanceAlongCurve. stack trace: \\n')\n        sys.stderr.write(traceback.format_exc())\n        raise\n    \ndef uninitializePlugin( mobject ):\n    mplugin = OpenMayaMPx.MFnPlugin( mobject )\n    try:\n        mplugin.deregisterNode( kPluginNodeId )\n\n        if (OpenMaya.MGlobal.mayaState() != OpenMaya.MGlobal.kBatch) and (OpenMaya.MGlobal.mayaState() != OpenMaya.MGlobal.kLibraryApp):\n            mplugin.deregisterCommand( kPluginCmdName )\n            mplugin.deregisterNode( kPluginNodeManipId )\n    except:\n        sys.stderr.write( 'Failed to deregister plugin instanceAlongCurve')\n        raise\n\n### UTILS\ndef getSingleSourceObjectFromPlug(plug):\n\n    if plug.isConnected():\n        # Get connected input plugs\n        connections = OpenMaya.MPlugArray()\n        plug.connectedTo(connections, True, False)\n\n        # Find input transform\n        if connections.length() == 1:\n            return connections[0].node()\n\n    return None\n\ndef getFnFromPlug(plug, fnType):\n    node = getSingleSourceObjectFromPlug(plug)\n\n    # Get Fn from a DAG path to get the world transformations correctly\n    if node is not None:\n        path = OpenMaya.MDagPath()\n        trFn = OpenMaya.MFnDagNode(node)\n        trFn.getPath(path)\n\n        path.extendToShape()\n\n        if path.node().hasFn(fnType):\n            return path\n\n    return None\n\n# TODO: cache this data to prevent recalculating when there is no manipulator being updated\ndef getSortedCurveAxisArray(mObject, curveAxisHandleArray, count):\n    axisHandles = []\n\n    expectedHandleCount = OpenMaya.MFnDependencyNode(mObject).findPlug(instanceAlongCurveLocator.curveAxisHandleCountAttr).asInt()\n\n    for i in xrange(min(expectedHandleCount, curveAxisHandleArray.elementCount())):\n        curveAxisHandleArray.jumpToArrayElement(i)\n        parameterHandle = curveAxisHandleArray.inputValue().child(instanceAlongCurveLocator.curveAxisHandleAttr.parameter)\n        angleHandle = curveAxisHandleArray.inputValue().child(instanceAlongCurveLocator.curveAxisHandleAttr.angle)\n        axisHandles.append((i, parameterHandle.asDouble(), angleHandle.asDouble()))\n\n    def getKey(item):\n        return item[1]\n\n    return sorted(axisHandles, key=getKey)\n\ndef printVector(v, s=None):\n    print s + \":\" + str(v.x) + \", \" + str(v.y) + \", \" + str(v.z)\n" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Add polygons to the selected polygon objects to smooth them" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Smooth" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "polySmooth.png" 
        -image1 "polySmooth.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "polyPerformAction \"polySmooth  -mth 0 -sdt 2 -ovb 1 -ofb 3 -ofc 0 -ost 0 -ocr 0 -dv 1 -peh 0 -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -sl 1 -dpe 1 -ps 0.1 -ro 1\" f 0" 
        -sourceType "mel" 
        -doubleClickCommand "performPolySmooth 1" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Duplicate the selected object(s)" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Duplicate Special" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "DS_SPC" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "menuIconEdit.png" 
        -image1 "menuIconEdit.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "duplicatePreset(1,0,1,0,0,0,0,0,0,0,0,0,0,0,-1,1,1)" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Create a polygonal cylinder on the grid" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Cylinder" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "polyCylinder.png" 
        -image1 "polyCylinder.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "setToolTo CreatePolyCylinderCtx" 
        -sourceType "mel" 
        -doubleClickCommand "CreatePolygonCylinderOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Automatically soften/harden edges based on face angle" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Harden Edge" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "polyHardEdge.png" 
        -image1 "polyHardEdge.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SoftPolyEdgeElements 0" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Automatically soften/harden edges based on face angle" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Soften Edge" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "polySoftEdge.png" 
        -image1 "polySoftEdge.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "SoftPolyEdgeElements 1" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Create a polygonal cube on the grid" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Cube" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "polyCube.png" 
        -image1 "polyCube.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "polyCube -w 100 -h 100 -d 100 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 1; objectMoveCommand;" 
        -sourceType "mel" 
        -doubleClickCommand "CreatePolygonCubeOptions" 
        -commandRepeatable 1
        -flat 1
    ;

} 
